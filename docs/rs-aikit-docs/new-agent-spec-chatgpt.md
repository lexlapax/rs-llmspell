# Standardizing Portable AI Agent Definitions

## Emerging Agent Definition Languages

### Agent Definition Language (ADL) – Eclipse/NextMoca

One promising approach is **Agent Definition Language (ADL)**, recently introduced via the Eclipse LMOS project. ADL aims to be a **structured, model-agnostic specification for AI agents**, analogous to how HTML standardized web content[\[1\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=It%20reminded%20us%20of%20the,custom%20markup%2C%20and%20nothing%20interoperated)[\[2\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=At%20its%20core%2C%20ADL%20is,AI%20agent%20fully%20and%20unambiguously). In an ADL spec (expressed in JSON or YAML), you describe an agent’s role/purpose, its capabilities and tools, expected inputs/outputs, workflow logic, data contexts, safety constraints, and even LLM parameters or preferences[\[2\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=At%20its%20core%2C%20ADL%20is,AI%20agent%20fully%20and%20unambiguously). In other words, **ADL serves as a complete “blueprint” of an agent’s behavior and permissions**, independent of any specific model or code. This decoupling means the same ADL-defined agent can be deployed on different frameworks or LLM backends with minimal changes[\[3\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=In%20other%20words%3A). ADL explicitly includes modern AI agent needs – for example, you can list **tools or APIs the agent may call**, specify **retrieval-augmented generation (RAG) data sources** (documents, vector indices) the agent can use, and set **LLM settings** like model names or decoding parameters[\[4\]](https://github.com/nextmoca/adl#:~:text=ADL%20,readable%20agent%20blueprint). The focus is on making agent logic transparent, governable, and shareable: business or domain experts could define behaviors in ADL (with constructs for conditional steps, fallbacks, etc.) instead of burying logic in brittle prompt scripts[\[5\]](https://eclipse.dev/lmos/docs/arc/adl/#:~:text=4). By providing a **standard contract for what an agent is allowed to do and how it should behave**, ADL hopes to eliminate the fragmentation of one-off agent definitions and enable true portability[\[6\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=And%20as%20the%20ecosystem%20grows%2C,the%20fragmentation%20grows%20with%20it)[\[7\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=,LLM%2Fruntime%20preferences).

### Open Agent Specification (Agent Spec) – Oracle

Another leading proposal is Oracle’s **Open Agent Specification (commonly called Agent Spec)**. This approach is often likened to **“ONNX for AI agents”**, i.e. a universal intermediate representation that separates agent design from execution[\[8\]](https://medium.com/my-aiml/the-universal-language-for-ai-agents-a84b5c4e90b2#:~:text=Enter%20AgentSpec%20,agent%20design%20from%20execution%20details). Agent Spec was first released in late 2024 and provides a **framework-neutral, declarative language** to define not only individual agents but also their multi-step workflows and compositions[\[8\]](https://medium.com/my-aiml/the-universal-language-for-ai-agents-a84b5c4e90b2#:~:text=Enter%20AgentSpec%20,agent%20design%20from%20execution%20details)[\[9\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=Open%20Agent%20Specification%20,By%20making%20agent). Under Agent Spec, an agent system is built from modular **components**: you have components for single **Agents** (LLM-driven assistants), for **Flows** (predefined workflows or scripts of actions), and for various action nodes (like an **LLMNode** that encapsulates a prompt to the model, or a **ToolNode** for an API call)[\[10\]](https://oracle.github.io/agent-spec/development/#:~:text=Image%3A%20Agents)[\[11\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=defining%20agents%2C%20their%20workflows%2C%20and,for%20GUIs%20or%20advanced%20validation). These components are described in JSON/YAML with a **schema-driven rigor** – inputs and outputs are defined via JSON Schema, and components can reference each other, allowing data to flow between steps in a controlled way[\[11\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=defining%20agents%2C%20their%20workflows%2C%20and,for%20GUIs%20or%20advanced%20validation)[\[12\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=,design%20time%20against%20JSON%20schemas). Crucially, Agent Spec makes workflows explicit: you can model complex **control flows** (sequence, branching conditions, loops) and **data flows** between nodes, essentially drawing a directed graph of the agent’s decision/process logic that is validated at design time[\[12\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=,design%20time%20against%20JSON%20schemas). This structured approach promotes reliability and clarity – for example, one can visualize or formally verify the agent’s flow logic. Agent Spec is also **extensible**: developers can define new component types for custom needs, and the spec’s roadmap includes first-class support for things like **memory modules, planning modules, data stores, and even wrapping remote agents as components**[\[13\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=The%20Agent%20Spec%20technical%20report,outlines%20several%20roadmap%20priorities). The goal is to enable “**write once, run anywhere**” for agents and their workflows – you could author an Agent Spec JSON and then execute it on any compatible runtime (adapters exist for frameworks like LangChain’s LangGraph, Microsoft Autogen, etc.)[\[14\]](https://oracle.github.io/agent-spec/development/#:~:text=Agent%20Spec%20configurations%20can%20be,AutoGen%20and%20LangGraph%2C%20through%20adapters)[\[8\]](https://medium.com/my-aiml/the-universal-language-for-ai-agents-a84b5c4e90b2#:~:text=Enter%20AgentSpec%20,agent%20design%20from%20execution%20details). By formalizing agent behaviors in a neutral format, Agent Spec helps avoid framework lock-in and makes complex multi-agent systems easier to share and reproduce[\[9\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=Open%20Agent%20Specification%20,By%20making%20agent). In summary, it is a very **architecturally thought-out** standard, covering standalone agents, tool usage, and multi-agent orchestration with a strong emphasis on modularity and reuse[\[15\]](https://oracle.github.io/agent-spec/development/#:~:text=Open%20Agent%20Specification%20,agent%20systems)[\[16\]](https://oracle.github.io/agent-spec/development/#:~:text=Modular%20%26%20Reusable%20Agent%20Spec%E2%80%99s,complex%20assistants%20faster%20and%20simpler).

### Other Markup Approaches and Protocol Definitions

Beyond ADL and Agent Spec, there are other efforts to define agents or their interactions in a portable way – though many are narrower in scope or targeting specific niches. For instance, the **Hyper Agent Markup Language (HAML)** is an experimental format inspired by HTML, which uses tag-like syntax (e.g. \<conversation\>, \<agent\>, \<context\>) to script out multi-agent dialogues[\[17\]](https://ai-network.medium.com/haml-hyper-agent-markup-language-a-new-frontier-in-ai-0f749bc30164#:~:text=structured%20to%20HTML%20in%20that,to%20define%20and%20display%20information). HAML was introduced to facilitate dynamic AI-to-AI conversations (such as debate or collaborative reasoning between agents) in a transparent, standardized way – even recording those interactions on a blockchain for auditability[\[18\]](https://ai-network.medium.com/haml-hyper-agent-markup-language-a-new-frontier-in-ai-0f749bc30164#:~:text=Press%20enter%20or%20click%20to,view%20image%20in%20full%20size). While intriguing, HAML is mostly focused on conversation structure and visualization, and it’s not yet a widely adopted general agent definition standard. Another angle is the **metadata manifests used by agent communication protocols**. For example, the Agent-to-Agent protocol (A2A, an open standard initially from Google) defines an **Agent Card** – essentially a JSON file (often hosted at a well-known URL like /.well-known/agent.json) that acts as the agent’s “business card”[\[19\]](https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/#:~:text=Capability%20discovery%3A%20Agents%20can%20advertise,agent%20to%20identify%20the)[\[20\]](https://a2a-protocol.org/v0.3.0/specification/#:~:text=Agent%20Card%3A%20A%20JSON%20metadata,service%20endpoint%2C%20and%20authentication). An A2A Agent Card describes key info about an agent: its identity, offered capabilities or skills (what it can do or what tasks it can fulfill), any special requirements, and the network endpoint where it can be reached[\[20\]](https://a2a-protocol.org/v0.3.0/specification/#:~:text=Agent%20Card%3A%20A%20JSON%20metadata,service%20endpoint%2C%20and%20authentication). This is used for discovery and handshake in A2A. IBM’s Agent Communication Protocol (ACP) has a similar concept of an **Agent Manifest** with identity, capabilities, and metadata for an agent[\[21\]](https://agentcommunicationprotocol.dev/core-concepts/agent-manifest#:~:text=Agent%20Manifest%20The%20Agent%20Manifest,capabilities%2C%20metadata%2C%20and%20runtime%20status). These manifest schemas are important for **interoperability**, but note that they are fairly high-level – they advertise an agent’s interface and permissions rather than fully specifying internal logic. Historically, there have even been early attempts like the **DARPA Agent Markup Language (DAML)** dating back to the Semantic Web era, though that was more about ontology and knowledge representation on the web than about LLM-based agent behaviors. In the modern context, ADL and Agent Spec are the **clearest attempts at a comprehensive agent definition language**. Other frameworks or standards might pop up (for example, you might encounter terms like *Agentic Schema Framework* or *Semantic Agent Cards* in research literature, focusing on semantic interoperability and trust), but many of those address specific facets (like security, credentials, or semantic descriptions) and could complement an ADL/AgentSpec-style core definition rather than replace it.

## Overlaps and Complementarity of Approaches

It’s encouraging that ADL and Agent Spec have **convergent goals** despite coming from different organizations – this suggests the community sees a real need for standardization. Both approaches try to solve the same fundamental problem: *everybody has been defining AI agents differently, leading to fragmentation*[\[22\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=Everyone%20defines%20agents%20differently). Accordingly, both ADL and Agent Spec strive to be **vendor-neutral, human-readable, and machine-parseable formats** to describe what an agent is and does, in a way that’s portable across runtime platforms[\[6\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=And%20as%20the%20ecosystem%20grows%2C,the%20fragmentation%20grows%20with%20it)[\[16\]](https://oracle.github.io/agent-spec/development/#:~:text=Modular%20%26%20Reusable%20Agent%20Spec%E2%80%99s,complex%20assistants%20faster%20and%20simpler). There is significant overlap in what they cover. For example, **defining tools/capabilities** an agent can use is central to both (ADL lists tools and their parameters explicitly[\[23\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=,LLM%2Fruntime%20preferences), and Agent Spec represents tools as components/nodes). **Workflow or logic definition** is present in both (ADL supports sequences of steps with conditionals and fallback logic[\[5\]](https://eclipse.dev/lmos/docs/arc/adl/#:~:text=4), while Agent Spec has an explicit graph of nodes and edges for control flow[\[12\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=,design%20time%20against%20JSON%20schemas)). Both allow specification of **LLM model settings** (e.g. which model or inference engine to use and with what parameters) and incorporate **governance or constraints** (like ADL’s safety constraints, or the fact that an Agent Spec definition can be validated against rules before deployment). In essence, **ADL and Agent Spec fill a similar “definition layer” in the AI stack** – a layer that has been missing until now[\[24\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=)[\[25\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=Purpose%3A%20ADL%20defines%20what%20an,A2A%20defines%20how%20agents%20interact).

That said, there are some differences in philosophy and granularity. ADL is positioned to be **declarative and accessible to non-programmers** (the Eclipse team touts it as business-friendly) – it abstracts away low-level details and focuses on capturing an agent’s intended behavior, with built-in structures for things like alternate solutions and failure handling to make agents more resilient[\[5\]](https://eclipse.dev/lmos/docs/arc/adl/#:~:text=4). In contrast, Agent Spec takes a more **formal and engineering-centric approach**, with a strong emphasis on modularity, type-checking and precise flow control[\[12\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=,design%20time%20against%20JSON%20schemas). This means Agent Spec might be better suited when you need very fine-grained control over an agent’s decision graph or want to integrate with software tooling (IDE plugins, visual editors, etc.) that leverage the schema. ADL, on the other hand, might shine when rapidly specifying an agent’s behavior at a slightly higher level – potentially one ADL “use case” could be compiled into a more detailed graph behind the scenes. We can think of it this way: **ADL defines an agent at a design level, agnostic of runtime, and Agent Spec similarly defines agents plus workflows at design time – neither is an execution engine by itself**. They are complementary with the *execution* layer standards like A2A and MCP. In fact, the creators of ADL explicitly note that **ADL is *not a replacement for protocols like A2A or MCP, but works alongside them[\[24\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=). ADL or Agent Spec tells you what an agent can do and how it is structured; meanwhile, MCP (Model Context Protocol) would be used at runtime to let the agent actually call a tool or fetch context in a standardized way, and A2A would be used for one agent to send a task request to another agent over HTTP/JSON-RPC[\[26\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=What%20MCP%20Is)[\[27\]](https://oracle.github.io/agent-spec/development/#:~:text=Agent%20Spec%20aims%20to%20streamline,details%20of%20specific%20agentic%20frameworks). For example, you might define an agent in ADL, specifying that it has the capability to get weather info via a get\_weather tool, and at runtime the agent would invoke that tool through an MCP call (which formats the JSON-RPC request and handles the response)[\[28\]](https://akka.io/blog/mcp-a2a-acp-what-does-it-all-mean#:~:text=Overview%3A)[\[29\]](https://akka.io/blog/mcp-a2a-acp-what-does-it-all-mean#:~:text=Features%3A). Or consider inter-agent orchestration: an agent’s ADL could declare that it may delegate subtasks to other agents; the actual messaging to a remote agent would happen via A2A protocol calls, possibly facilitated by an Agent Card to discover the remote agent’s endpoint[\[19\]](https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/#:~:text=Capability%20discovery%3A%20Agents%20can%20advertise,agent%20to%20identify%20the)[\[20\]](https://a2a-protocol.org/v0.3.0/specification/#:~:text=Agent%20Card%3A%20A%20JSON%20metadata,service%20endpoint%2C%20and%20authentication). In short, the definition languages (ADL/Agent Spec) and the communication protocols (A2A, MCP, ACP, etc.) are complementary pieces*** of a full agent ecosystem[\[27\]](https://oracle.github.io/agent-spec/development/#:~:text=Agent%20Spec%20aims%20to%20streamline,details%20of%20specific%20agentic%20frameworks). The definition provides a portable blueprint, and the protocols provide the interoperability and integration at runtime.

One could imagine using them together: for instance, define an agent’s full blueprint in ADL or Agent Spec, and include in that definition references to any external dependencies (tools, other agents). The agent’s “capabilities” section might align with what ends up in an A2A Agent Card (advertising *which* tasks it can do), and the “tools” section might map to MCP endpoints that the agent can call for extra knowledge. This layered approach is analogous to how in web development you have a declarative API spec (e.g. OpenAPI) separate from the HTTP protocol that clients/servers actually use to communicate – in fact, ADL is explicitly likened to *“OpenAPI for agents”*, defining the agent’s contract, whereas A2A is likened to the HTTP layer enabling agents to communicate and fulfill those contracts[\[30\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=Executability%3A%20ADL%20is%20not%20executable%3B,A2A%20governs%20runtime%20flows).

## Incorporating Context, Memory, and Knowledge in the Spec

Your additional requirements – context engineering, graph/RAG-based retrieval, agent memory, user memory – are absolutely critical for real-world agents, and any comprehensive agent specification should account for them. The good news is that these concepts are being included, but we need to consider **how** to represent them in a portable way. Let’s break down the pieces:

* **Context Engineering & RAG Sources:** Modern LLM-based agents often fetch external context (documents, knowledge base info, etc.) to augment their prompts (this is the Retrieval-Augmented Generation paradigm). In a spec like ADL or Agent Spec, this would typically be captured under something like a **“data sources” or “context” section**. ADL explicitly lists *“context or data sources”* as part of an agent definition[\[31\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=,LLM%2Fruntime%20preferences), and the ADL GitHub description calls out *“RAG inputs”* as a first-class element alongside tools and LLM settings[\[4\]](https://github.com/nextmoca/adl#:~:text=ADL%20,readable%20agent%20blueprint). This means in ADL you could specify, for example, that the agent has access to a particular vector database or knowledge graph, possibly by name or by some connection details. Agent Spec doesn’t use the term RAG outright in its current spec, but it supports the concept through its extensibility – you can define a **Tool component or node** that performs a knowledge lookup (e.g. a “ResearchNode” that given a query will search a documents index). In the Agent Spec Technical Report, it’s mentioned that future extensions will include **datastore components**[\[13\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=The%20Agent%20Spec%20technical%20report,outlines%20several%20roadmap%20priorities), so formally modeling a knowledge base or retrieval action is on the roadmap. In practice right now, one might simply treat a retrieval as a kind of tool call: e.g., define a tool API that the agent can call (via MCP in runtime) to query a knowledge base. The spec would list that tool in the agent’s capabilities and thereby ensure any runtime knows this agent might invoke that context.

* **Long-term Agent Memory:** By “agent memory” we typically mean the agent’s own accumulating knowledge from past interactions or experiences, beyond what’s in the immediate prompt. This could be implemented as, say, an **embedding-based memory store** that the agent uses to persist and retrieve chat history or learned facts. The agent spec should allow us to specify that such a memory mechanism is present. How to do this? One approach is to treat the memory store as a special kind of **resource or sub-component**. For example, Agent Spec could model a memory module as a component with certain inputs/outputs (perhaps a component that takes a query and returns a retrieved snippet, or that can be updated with new data). In fact, as noted, Agent Spec plans to incorporate *memory modules* directly[\[13\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=The%20Agent%20Spec%20technical%20report,outlines%20several%20roadmap%20priorities). So you might eventually see something like a "component\_type": "MemoryStore" in an Agent Spec JSON, with properties like embedding\_model, index\_name, etc., and the agent’s LLM node might reference that memory component to pull context. In ADL, there isn’t a pre-defined “memory” object in the spec right now, but you **can still include memory via the context mechanism** – e.g., define one of the agent’s data sources as “AgentMemory: description of what it contains or how to retrieve from it”. The details of implementation (like whether it’s a Vector DB or a simple file) might be abstracted, but the spec can indicate that this agent *has persistent memory* and perhaps what kind (transient vs long-term, private vs shared).

* **User Memory / Profile:** This refers to storing information about the user (preferences, past instructions, etc.) that the agent can leverage. From a spec perspective, user-specific context can be handled similarly to agent memory – it’s another source of information. You might want to distinguish it from the agent’s own knowledge, though. In a well-structured spec, you could have **two separate context resources**: one for “agentMemory” and one for “userProfile”. For example, an agent definition might declare that it has access to UserProfileStore (with fields like user name, past queries, or any domain-specific data about the user) and a separate KnowledgeBase for general info. Both ADL and Agent Spec would allow such distinctions; you’d list them either as different tools or data components. The key is to clearly label these in the agent’s definition so that any runtime implementing the agent knows to initialize/connect those resources. By making it explicit in the spec, you also enable governance – e.g., you could include in the **governance constraints** that certain data should not be persisted beyond a session, etc., and an auditing system could verify the agent spec for compliance[\[7\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=,LLM%2Fruntime%20preferences).

* **Which “Layer” to put them in?** You asked whether to put these in “layer 5” or break them into different layers. Interpreting that, it sounds like you’re considering a layered architecture for agents. In many designs, the **top layer (let’s call it Layer 5\)** is the *declarative specification layer*, where we describe the agent’s blueprint (this is essentially where ADL or Agent Spec operate)[\[25\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=Purpose%3A%20ADL%20defines%20what%20an,A2A%20defines%20how%20agents%20interact). Within that layer, you can certainly have subsections or components – e.g., one part of the spec defines the core reasoning workflow, another part lists external knowledge sources. But they would all reside in the overall agent definition document. It’s usually not necessary to split memory and context into entirely separate definition layers; instead, they are **different facets of the agent, captured in different sections of the spec**. For clarity and modularity, you might conceptually label them as sub-layers or modules: for instance, **Layer 5a: Knowledge/Memory module specs**, **Layer 5b: Tool/action specs**, **Layer 5c: Dialogue/Reasoning workflow**. But ultimately all of that information gets unified in the agent’s definition file (which is “layer 5” as a whole, the spec). Both ADL and Agent Spec are flexible enough to incorporate these facets: ADL can include context and memory in the definition (under something like a context or data section)[\[4\]](https://github.com/nextmoca/adl#:~:text=ADL%20,readable%20agent%20blueprint), and Agent Spec will likely treat memory or context providers as just another component type in the JSON graph[\[13\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=The%20Agent%20Spec%20technical%20report,outlines%20several%20roadmap%20priorities). So, I would **break down the concerns logically (memory vs tools vs core logic)** *within* the spec, but keep them as part of one comprehensive agent spec layer rather than trying to create a completely separate layer for memory. This ensures that when an agent is packaged or shared, it comes with knowledge of all its dependencies (tools, data stores, etc.) in one place.

In summary, you should extend your agent specification to explicitly cover **contextual resources**. List the sources of information the agent can draw on – be it an embedded vector index, a SQL database, a user profile store, or even a static knowledge graph. Define how the agent uses them (e.g. “before answering a question, it will query Resource X for relevant info”). By doing so in the spec, any runtime that implements the agent can set up the required connections (for example, mounting a database or ensuring the agent calls the right API for retrieval). This approach aligns well with the spirit of both ADL and Agent Spec: they seek to make such dependencies explicit and standardized, rather than hidden in prompt engineering. It also makes it easier to swap out implementations (say, you could replace a proprietary vector DB with an open-source one, and only the agent spec needs to be updated to point to the new resource, without changing the agent’s logic).

## Workflows, Composition, and Hierarchical Agents

Your question about workflows – especially complex ones with parallel, sequential, looped, or conditional structures – is very relevant. In many cases, what we call an “agent” is actually an **orchestration of multiple steps or even multiple sub-agents** working together. Both ADL and Agent Spec account for this, though in slightly different ways, and it ties back into how we define an agent’s scope.

**Agent Spec’s approach to workflows:** Agent Spec explicitly distinguishes between an **Agent** and a **Flow**. An Agent (in Agent Spec terms) is something that can interact (take input, produce output, possibly talk to user or other agents), whereas a Flow is more like a **script or DAG of operations** that can be executed autonomously[\[32\]](https://oracle.github.io/agent-spec/development/#:~:text=Image%3A%20Flows). In practice, a Flow could be a recipe of actions: e.g., first do Task A, then if result is X do Task B (in parallel with Task C), else do Task D, etc. Agent Spec models these flows with nodes and edges, supporting branching (conditional logic), and one can imagine loop constructs (a loop could be represented by edges that form a cycle in the graph, though such usage would be carefully controlled to avoid infinite loops)[\[12\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=,design%20time%20against%20JSON%20schemas)[\[33\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=Workflow%20connectivity%20is%20described%20using,well%20as%20visual%20pipeline%20construction). Each node in a flow could be a primitive action (like an LLM call, a tool call) or even a nested flow. This means you can build **hierarchical workflows**. If you want to expose a complex workflow as a single “agent service,” you could wrap a Flow with an Agent interface. For example, define a Flow that orchestrates several steps (some in parallel, some conditional), and then define an Agent whose behavior is essentially to execute that Flow when triggered. Because Agent Spec treats flows and agents as components, you can mix and match – an Agent can contain (or call) a sub-flow, and a Flow could in theory invoke another Agent as a step (perhaps via an agent node or an API call). The standard even envisions **multi-agent systems**: you can compose multiple Agent definitions and connect them, or have an agent spawn another. The important thing is that **the workflow logic is all declaratively captured** so you or others can understand it without diving into code[\[12\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=,design%20time%20against%20JSON%20schemas).

**ADL’s approach to workflows:** ADL is also designed to handle complex logic, but it doesn’t use a graph model on the surface. Instead, it appears more linear but with special constructs. In ADL, you define a *“use case”* (which is essentially an agent’s behavior scenario), and you can have that use case broken into **steps** (which can correspond to sub-tasks or function calls) and **conditions/branches**. The ADL documentation highlights support for *conditionals* and even mentions that you can include an *“Alternative Solution”* and a *“Fallback Solution”* as optional paths if the main plan fails[\[34\]](https://eclipse.dev/lmos/docs/arc/adl/adl_cheat/#:~:text=Alternative%20Solution%20,Last%20resort%2C%20avoids%20loops). In practice, this means you can encode things like: “First try method A; if that doesn’t work (condition not satisfied), try method B as a backup; if all else fails, do C as a fallback.” This covers sequential and conditional logic, as well as failure recovery, which is crucial in agents (to avoid getting stuck in loops of errors)[\[34\]](https://eclipse.dev/lmos/docs/arc/adl/adl_cheat/#:~:text=Alternative%20Solution%20,Last%20resort%2C%20avoids%20loops). For parallelism, ADL doesn’t explicitly mention running steps in parallel (since it’s largely written as a sequence of steps in a YAML/JSON), but you could likely achieve parallel behavior by having multiple agents running concurrently coordinated by an external orchestrator or by splitting tasks and then merging results in a step. If parallel flows are a major requirement, Agent Spec’s graph structure might represent that more naturally (e.g., two branches stemming from a decision node could be run in parallel and then joined). However, even without formal parallel notation, you can model many parallel scenarios as separate sub-agents in ADL.

**Workflows as Agents:** You raised the point of a complex workflow being presented as an agent – this is a key concept often called a *meta-agent* or *orchestrator agent*. Both standards allow this kind of abstraction. In ADL, the notion of *“use case references”* lets one agent’s definition include invoking another use case[\[35\]](https://eclipse.dev/lmos/docs/arc/adl/#:~:text=,case%20references%C2%A0to%20link%20complex%20workflows). In simpler terms, you might have a master ADL file that says: *Step 1: call agent X to do subtask; Step 2: call agent Y to do another subtask; then merge results*. Each of those agents X and Y could themselves be defined in ADL separately. So ADL supports a hierarchical composition: smaller agent behaviors can be building blocks for bigger ones[\[35\]](https://eclipse.dev/lmos/docs/arc/adl/#:~:text=,case%20references%C2%A0to%20link%20complex%20workflows). In Agent Spec, as described, you could either treat sub-agents as just another node type or you could design one big flow that encapsulates what those sub-agents would do (if you want to keep it in one file). Since Agent Spec aims to be an intermediate format, one approach is to actually import other Agent Spec files as components – for instance, an “Agent node” that references an Agent Spec definition of another agent (there isn’t an explicit example of that in the documentation we saw, but the standard is extensible and this would align with its purpose of multi-agent composition[\[15\]](https://oracle.github.io/agent-spec/development/#:~:text=Open%20Agent%20Specification%20,agent%20systems)[\[27\]](https://oracle.github.io/agent-spec/development/#:~:text=Agent%20Spec%20aims%20to%20streamline,details%20of%20specific%20agentic%20frameworks)).

In any event, **workflows fit naturally into the agent spec layer** rather than being a separate layer. We often talk about an “agentic workflow” – that’s just an agent (or multi-agent system) executing a series of actions according to a plan. The role of the specification is to capture that plan in a portable way. So, whether it’s sequential steps or branching flows or loops, you’d include that in the agent’s definition. For readability and maintenance, you might break a very complex process into subcomponents (like separate flows or agents as mentioned), but those are still part of the overall spec ecosystem. Think of how a complex software program might be broken into functions or modules – here a complex agent workflow can be broken into sub-agents or sub-flows, which are then assembled.

**Parallel, Conditional, Loop constructs:** Agent Spec explicitly provides constructs for conditional branching (via BranchingNode or similar) and could allow parallel execution if two nodes are independent (since the spec doesn’t forbid it, a compatible runtime could execute independent branches concurrently). Looping can be achieved by a flow that cycles back to an earlier node (with appropriate loop conditions) – though one must be careful with open-ended loops; typically you’d implement a loop as “while condition X, do Y” which Agent Spec could model by a branch that goes back upward if X is true. ADL, being more linear, likely doesn’t encourage arbitrary loops (to avoid infinite self-prompts), but you can implement iterative behavior by recursion or re-invocation with updated context. For example, an ADL agent could have a step that says “if incomplete, call itself again with the updated state” – not unlike how AutoGPT loops, but you’d explicitly allow it only a certain number of times or have a fallback to break out (they even mention that their fallback solution design is meant to **avoid loops** running endlessly[\[34\]](https://eclipse.dev/lmos/docs/arc/adl/adl_cheat/#:~:text=Alternative%20Solution%20,Last%20resort%2C%20avoids%20loops)). So, yes, loops are possible but controlled.

**Summary:** Workflows should be thought of as *part of the agent definition*, not external to it. In your spec design, you might have a section or structure that defines the sequence/graph of tasks (the workflow). This could be layer 5 in your architecture, alongside the other details. If you prefer layering conceptually: you might say Layer 4 is the runtime orchestration and Layer 5 is the static workflow blueprint. But practically, when writing the spec, you’ll describe the workflow in the same JSON/YAML document that describes the agent’s capabilities. Both ADL and Agent Spec give you patterns to do this: **ADL with use-case steps (including invoking other agents or tools), and Agent Spec with flow graphs**. The complex workflow can indeed be presented to other platforms as just another agent – you’d basically provide the top-level agent spec, and inside it, it references all the sub-actions. As long as the other platform understands the same standard (ADL or Agent Spec), it can instantiate that complex agent. This is powerful: it means you could design, say, a multi-step research-and-report agent on your platform and export its ADL/AgentSpec file, and another team could run that agent on their own infrastructure, and it would perform the same multi-step process.

## Recommendation and Next Steps

Considering all the above, here’s a holistic recommendation for defining portable agents given your goals (building your own Rust-based stack, but leveraging existing standards and ensuring interoperability):

**1\. Embrace an Open Specification (or Two) as Your Base:** Rather than inventing a completely proprietary agent definition format, it’s wise to build atop the momentum of ADL or Agent Spec. These are currently the *most prevalent and well-architected* proposals in this space, and using them will save you design time and make your system more future-proof. Based on what we’ve seen, **Agent Spec** is very comprehensive and might align well with your “structural first, then runtime” philosophy – it clearly separates the static definition (JSON/YAML spec) from execution, and it provides constructs for all the structural elements (agents, tools, flows, etc.) you need[\[8\]](https://medium.com/my-aiml/the-universal-language-for-ai-agents-a84b5c4e90b2#:~:text=Enter%20AgentSpec%20,agent%20design%20from%20execution%20details)[\[27\]](https://oracle.github.io/agent-spec/development/#:~:text=Agent%20Spec%20aims%20to%20streamline,details%20of%20specific%20agentic%20frameworks). Implementing support for Agent Spec in your Rust platform could be as straightforward as creating data models for the spec’s schema (since it’s JSON-based) and then writing an interpreter or compiler that turns that spec into running agent instances and workflows in Rust. On the other hand, **ADL** offers a slightly higher-level, declarative style that might be friendlier for certain users (non-programmers defining agents). You might consider supporting ADL as well – for example, you could allow agent authors to write an ADL YAML, and under the hood your system could convert it into an Agent Spec-like internal representation or directly interpret it (since ADL is also declarative). The good news is ADL and Agent Spec are not at odds: they largely overlap in function, so it’s conceivable that **one could translate an ADL file into the equivalent Agent Spec JSON** or vice versa with some work, as both enumerate similar concepts (roles, steps, tools, etc.). In fact, you might monitor community developments – it’s possible that over time these efforts could converge or at least tools will emerge to bridge between them. By aligning with both, you ensure maximum compatibility. At the very least, I recommend **designing your own Rust agent schema to be compatible with the key ideas from these standards** – for example, use similar fields (like “tools”, “workflow”, “inputs/outputs”, “memory”, etc.) so that mapping to an open format later will be straightforward.

**2\. Integrate Context and Memory as First-Class Citizens:** Make sure your agent spec includes sections for context resources, long-term memory, and user-specific data, as we discussed. In practice, you might have structures like: a list of “KnowledgeSources” each with a type (vector\_index, database, API, etc.) and an identifier. An agent’s logic can then reference these by name (e.g., a step might say: search KnowledgeSource\["CompanyDocs"\] for keywords X). This way, anyone reading the spec knows what external information the agent can pull in. If you adopt Agent Spec, you might implement this as a custom component or wait for their official memory/datastore components[\[13\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=The%20Agent%20Spec%20technical%20report,outlines%20several%20roadmap%20priorities). With ADL, you could include it in the “context” definition portion[\[4\]](https://github.com/nextmoca/adl#:~:text=ADL%20,readable%20agent%20blueprint). By doing this now, you’ll have an architecture ready for advanced context engineering techniques (like retrieving relevant context chunks, caching summaries in memory, etc.). And because it’s in the spec, when you present your agent to another platform, they’ll also know to provide those same resources. For example, if your agent uses a UserProfile context, another platform seeing the spec will understand “I need to supply or simulate that UserProfile data for this agent to function correctly.”

**3\. Plan for Workflows and Modular Composition:** Given that you want to possibly orchestrate tasks in parallel, with loops, etc., ensure your spec (and your runtime) can represent **branching and concurrency**. If you go with Agent Spec’s model, this is built-in (directed graphs of nodes). In Rust, you might implement a small workflow engine that can take a graph from the spec and execute it (for example, one node might be “call LLM with prompt P”, another “if result contains X, follow edge A else edge B”, etc.). If you prefer a simpler start, you might restrict to sequential and conditional (no parallel) initially – that’s essentially what ADL does – and later extend to parallel execution when needed. Importantly, structure your system such that **one agent can invoke another** (either via your own internal call or via an A2A call). This hierarchical ability is important for scaling complexity. You mentioned possibly using MCP and A2A for parts on other platforms: indeed, if a subtask is better handled by a different system, your agent could issue an A2A request to an external agent. Make sure your spec can denote that (e.g., the capability “TranslateText” might be fulfilled by an external agent rather than a local tool, and that could be indicated by an endpoint or an agent identifier in the spec). In Agent Spec terms, that might be a **remote Agent component** (the spec’s roadmap even notes “remote agent constructs” as a future feature[\[13\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=The%20Agent%20Spec%20technical%20report,outlines%20several%20roadmap%20priorities)). In ADL, you might just document it as a step calling an external service. Either way, **workflows should be flexible** – your runtime might handle a loop by re-invoking an agent step, or handle parallel by spawning tasks, etc., but the key is the spec *describes* it so the behavior is consistent.

**4\. Leverage Protocol Standards for Interop:** Since you intend to eventually have pieces on other platforms and to present your agents to others, you should implement support for the relevant protocols. At minimum, supporting **A2A protocol** will let your agent communicate with agents outside your platform in a standard way. This means implementing the JSON-RPC 2.0 interface over HTTPS as per A2A spec[\[36\]](https://www.ibm.com/think/topics/ai-agent-protocols#:~:text=1,the%20format%20for%20data%20exchange), and hosting an Agent Card (the agent’s manifest JSON) at a well-known URL[\[19\]](https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/#:~:text=Capability%20discovery%3A%20Agents%20can%20advertise,agent%20to%20identify%20the)[\[20\]](https://a2a-protocol.org/v0.3.0/specification/#:~:text=Agent%20Card%3A%20A%20JSON%20metadata,service%20endpoint%2C%20and%20authentication). Likewise, consider implementing an **MCP client/server**: if your agent needs tools, you can either embed them in Rust or call an MCP server that provides them – using MCP ensures that down the line, you could swap in a different tool provider (for instance, Anthropic’s or IBM’s tool servers) without changing your agent. Essentially, by adhering to A2A and MCP, you **avoid vendor lock-in at the integration layer**, complementing the portability you achieve at the definition layer[\[27\]](https://oracle.github.io/agent-spec/development/#:~:text=Agent%20Spec%20aims%20to%20streamline,details%20of%20specific%20agentic%20frameworks). As an example, you might build your Rust runtime such that when an agent spec declares a tool (say “web\_search”), your runtime can either fulfill it internally or automatically route it as an MCP request to some known tool server. Similarly, if your agent spec says a subtask goes to agent “CalendarAgent”, your runtime could perform an A2A discovery for “CalendarAgent” and, if found, send the request over.

**5\. Iterate and Contribute:** Both ADL and Agent Spec are evolving (they’re quite new – ADL was open-sourced in late 2025, Agent Spec in 2024). Since you’re building your own implementation, you’ll likely gain insights and maybe find gaps. Don’t hesitate to engage with those communities (the ADL GitHub, Oracle’s Agent Spec repository) – you might propose enhancements or at least stay updated on changes. For instance, if you need to represent something like “user memory expires after 24h” and the spec doesn’t have a way to note that, you could suggest an extension. Being involved ensures your system stays aligned with the **most thought-out architectural ideas** in this domain, and you might influence them with your real-world use cases.

In conclusion, the **holistic architecture** would look like this: You define agents using a high-level specification (ADL or Agent Spec) that includes everything – from the model and prompt templates, to tools, to memory and context, to workflow logic and error handling. This spec (think of it as Layer 5 – the application layer of agent definitions) sits on top of a runtime stack. The runtime (Layers 1-4) involves the actual LLM engine (Layer 1), the agent’s reasoning/execution engine that interprets the spec (Layer 2), the interfaces to tools and data (Layer 3, e.g. MCP for tools, database connectors for knowledge, etc.), and the communication interface to other agents or users (Layer 4, e.g. using A2A or web APIs for multi-agent workflows). By clearly separating the **specification** from the **implementation layers**, you gain a lot of flexibility: you can swap out the LLM model or adjust temperature (just change a field in the spec), you can move a tool from local to remote (the spec remains the same, just the MCP endpoint changes), or even deploy the same agent on a different platform – as long as that platform supports the same spec/protocol standards, the agent will behave consistently[\[37\]](https://oracle.github.io/agent-spec/development/#:~:text=Image%3A%20Portable%20Across%20Frameworks)[\[38\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=How%20They%20Align%20Conceptually). This layered, standards-based approach is arguably the most **flexible and future-proof** path. It lets you “build first” – you have control over your own stack in Rust for performance and customization – but also “adopt existing” by adhering to the emerging common languages for agent definition. By doing so, you ensure your agents can interoperate in the growing ecosystem of agentic AI (across cloud platforms, enterprises, etc.), and you minimize the risk of being stuck with a solution that others can’t understand or integrate with. In short, **define your agents portably (using ADL/Agent Spec concepts) and implement them with interoperability in mind (using MCP/A2A), and you’ll have a robust, architecturally sound system** that can evolve along with the state of the art[\[39\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=How%20They%20Complement)[\[27\]](https://oracle.github.io/agent-spec/development/#:~:text=Agent%20Spec%20aims%20to%20streamline,details%20of%20specific%20agentic%20frameworks). Good luck with your project – it’s an exciting time to be working on these problems, and aligning with the right standards now will pay off greatly as agent-based systems become more standardized\!

**Sources:**

* Swanand Rao, *“Agent Definition Language (ADL): An Open Standard for Defining AI Agents,”* Medium (Dec 2025\)[\[2\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=At%20its%20core%2C%20ADL%20is,AI%20agent%20fully%20and%20unambiguously)[\[25\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=Purpose%3A%20ADL%20defines%20what%20an,A2A%20defines%20how%20agents%20interact)

* Eclipse LMOS ADL Documentation[\[5\]](https://eclipse.dev/lmos/docs/arc/adl/#:~:text=4) (flexibility and workflow in ADL)

* Oracle Open Agent Spec Documentation[\[15\]](https://oracle.github.io/agent-spec/development/#:~:text=Open%20Agent%20Specification%20,agent%20systems)[\[27\]](https://oracle.github.io/agent-spec/development/#:~:text=Agent%20Spec%20aims%20to%20streamline,details%20of%20specific%20agentic%20frameworks)

* *Open Agent Specification Technical Report,* arXiv (Benajiba et al., Oct 2025\) – summarized on EmergentMind[\[12\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=,design%20time%20against%20JSON%20schemas)[\[13\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=The%20Agent%20Spec%20technical%20report,outlines%20several%20roadmap%20priorities)

* IBM Think, *“What are AI Agent Protocols?”* (Rina Caballar, 2025\)[\[36\]](https://www.ibm.com/think/topics/ai-agent-protocols#:~:text=1,the%20format%20for%20data%20exchange)[\[40\]](https://www.ibm.com/think/topics/ai-agent-protocols#:~:text=,model%20and%20a%20websocket%20subprotocol)

* Google Developers Blog, *“Announcing the Agent2Agent (A2A) Protocol,”* (2023) – Agent Cards for discovery[\[19\]](https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/#:~:text=Capability%20discovery%3A%20Agents%20can%20advertise,agent%20to%20identify%20the)[\[20\]](https://a2a-protocol.org/v0.3.0/specification/#:~:text=Agent%20Card%3A%20A%20JSON%20metadata,service%20endpoint%2C%20and%20authentication)

* Akka AI Platform Blog, *“MCP, A2A, ACP: What does it all mean?”* (May 2025\)[\[41\]](https://akka.io/blog/mcp-a2a-acp-what-does-it-all-mean#:~:text=MCP%2C%20created%20by%20Anthropic%2C%20standardizes,instructions%20in%20a%20consistent%20manner)[\[42\]](https://akka.io/blog/mcp-a2a-acp-what-does-it-all-mean#:~:text=,and%20functionalities%20over%20a%20network) (overview of protocols)

* AI Network Medium, *“HAML — Hyper Agent Markup Language — A New Frontier in AI,”* (Sept 2024\)[\[17\]](https://ai-network.medium.com/haml-hyper-agent-markup-language-a-new-frontier-in-ai-0f749bc30164#:~:text=structured%20to%20HTML%20in%20that,to%20define%20and%20display%20information)[\[18\]](https://ai-network.medium.com/haml-hyper-agent-markup-language-a-new-frontier-in-ai-0f749bc30164#:~:text=Press%20enter%20or%20click%20to,view%20image%20in%20full%20size)

---

[\[1\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=It%20reminded%20us%20of%20the,custom%20markup%2C%20and%20nothing%20interoperated) [\[2\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=At%20its%20core%2C%20ADL%20is,AI%20agent%20fully%20and%20unambiguously) [\[3\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=In%20other%20words%3A) [\[6\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=And%20as%20the%20ecosystem%20grows%2C,the%20fragmentation%20grows%20with%20it) [\[7\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=,LLM%2Fruntime%20preferences) [\[22\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=Everyone%20defines%20agents%20differently) [\[23\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=,LLM%2Fruntime%20preferences) [\[24\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=) [\[25\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=Purpose%3A%20ADL%20defines%20what%20an,A2A%20defines%20how%20agents%20interact) [\[26\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=What%20MCP%20Is) [\[30\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=Executability%3A%20ADL%20is%20not%20executable%3B,A2A%20governs%20runtime%20flows) [\[31\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=,LLM%2Fruntime%20preferences) [\[38\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=How%20They%20Align%20Conceptually) [\[39\]](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa#:~:text=How%20They%20Complement) Agent Definition Language (ADL): An Open Standard for Defining AI Agents | by Swanand Rao | Dec, 2025 | Medium

[https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa](https://swanandrao.medium.com/agent-definition-language-adl-an-open-standard-for-defining-ai-agents-cdbd6bd098fa)

[\[4\]](https://github.com/nextmoca/adl#:~:text=ADL%20,readable%20agent%20blueprint) GitHub \- nextmoca/adl: ADL (Agent Definition Language) is a vendor-neutral, declarative standard for defining AI agents, including their tools, LLM settings, RAG inputs, permissions, and dependencies. It brings consistency, governance, and portability to enterprise AI by providing a clear, machine-readable agent blueprint.

[https://github.com/nextmoca/adl](https://github.com/nextmoca/adl)

[\[5\]](https://eclipse.dev/lmos/docs/arc/adl/#:~:text=4) [\[35\]](https://eclipse.dev/lmos/docs/arc/adl/#:~:text=,case%20references%C2%A0to%20link%20complex%20workflows) ARC Agent Definition Language | Eclipse LMOS

[https://eclipse.dev/lmos/docs/arc/adl/](https://eclipse.dev/lmos/docs/arc/adl/)

[\[8\]](https://medium.com/my-aiml/the-universal-language-for-ai-agents-a84b5c4e90b2#:~:text=Enter%20AgentSpec%20,agent%20design%20from%20execution%20details) The Universal Language for AI Agents | by Sanjay Basu, PhD | my\_aiml | Nov, 2025 | Medium

[https://medium.com/my-aiml/the-universal-language-for-ai-agents-a84b5c4e90b2](https://medium.com/my-aiml/the-universal-language-for-ai-agents-a84b5c4e90b2)

[\[9\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=Open%20Agent%20Specification%20,By%20making%20agent) [\[11\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=defining%20agents%2C%20their%20workflows%2C%20and,for%20GUIs%20or%20advanced%20validation) [\[12\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=,design%20time%20against%20JSON%20schemas) [\[13\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=The%20Agent%20Spec%20technical%20report,outlines%20several%20roadmap%20priorities) [\[33\]](https://www.emergentmind.com/topics/open-agent-specification-agent-spec#:~:text=Workflow%20connectivity%20is%20described%20using,well%20as%20visual%20pipeline%20construction) Agent Spec: Unified Agent Workflow Definition

[https://www.emergentmind.com/topics/open-agent-specification-agent-spec](https://www.emergentmind.com/topics/open-agent-specification-agent-spec)

[\[10\]](https://oracle.github.io/agent-spec/development/#:~:text=Image%3A%20Agents) [\[14\]](https://oracle.github.io/agent-spec/development/#:~:text=Agent%20Spec%20configurations%20can%20be,AutoGen%20and%20LangGraph%2C%20through%20adapters) [\[15\]](https://oracle.github.io/agent-spec/development/#:~:text=Open%20Agent%20Specification%20,agent%20systems) [\[16\]](https://oracle.github.io/agent-spec/development/#:~:text=Modular%20%26%20Reusable%20Agent%20Spec%E2%80%99s,complex%20assistants%20faster%20and%20simpler) [\[27\]](https://oracle.github.io/agent-spec/development/#:~:text=Agent%20Spec%20aims%20to%20streamline,details%20of%20specific%20agentic%20frameworks) [\[32\]](https://oracle.github.io/agent-spec/development/#:~:text=Image%3A%20Flows) [\[37\]](https://oracle.github.io/agent-spec/development/#:~:text=Image%3A%20Portable%20Across%20Frameworks) Open Agent Specification, Agent Spec — PyAgentSpec 26.1.0.dev0 documentation

[https://oracle.github.io/agent-spec/development/](https://oracle.github.io/agent-spec/development/)

[\[17\]](https://ai-network.medium.com/haml-hyper-agent-markup-language-a-new-frontier-in-ai-0f749bc30164#:~:text=structured%20to%20HTML%20in%20that,to%20define%20and%20display%20information) [\[18\]](https://ai-network.medium.com/haml-hyper-agent-markup-language-a-new-frontier-in-ai-0f749bc30164#:~:text=Press%20enter%20or%20click%20to,view%20image%20in%20full%20size) HAML — Hyper Agent Markup Language — A New Frontier in AI | by AI Network | Medium

[https://ai-network.medium.com/haml-hyper-agent-markup-language-a-new-frontier-in-ai-0f749bc30164](https://ai-network.medium.com/haml-hyper-agent-markup-language-a-new-frontier-in-ai-0f749bc30164)

[\[19\]](https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/#:~:text=Capability%20discovery%3A%20Agents%20can%20advertise,agent%20to%20identify%20the) Announcing the Agent2Agent Protocol (A2A)

[https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/](https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/)

[\[20\]](https://a2a-protocol.org/v0.3.0/specification/#:~:text=Agent%20Card%3A%20A%20JSON%20metadata,service%20endpoint%2C%20and%20authentication) Specification \- A2A Protocol

[https://a2a-protocol.org/v0.3.0/specification/](https://a2a-protocol.org/v0.3.0/specification/)

[\[21\]](https://agentcommunicationprotocol.dev/core-concepts/agent-manifest#:~:text=Agent%20Manifest%20The%20Agent%20Manifest,capabilities%2C%20metadata%2C%20and%20runtime%20status) Agent Manifest

[https://agentcommunicationprotocol.dev/core-concepts/agent-manifest](https://agentcommunicationprotocol.dev/core-concepts/agent-manifest)

[\[28\]](https://akka.io/blog/mcp-a2a-acp-what-does-it-all-mean#:~:text=Overview%3A) [\[29\]](https://akka.io/blog/mcp-a2a-acp-what-does-it-all-mean#:~:text=Features%3A) [\[41\]](https://akka.io/blog/mcp-a2a-acp-what-does-it-all-mean#:~:text=MCP%2C%20created%20by%20Anthropic%2C%20standardizes,instructions%20in%20a%20consistent%20manner) [\[42\]](https://akka.io/blog/mcp-a2a-acp-what-does-it-all-mean#:~:text=,and%20functionalities%20over%20a%20network) MCP, A2A, ACP: What does it all mean?

[https://akka.io/blog/mcp-a2a-acp-what-does-it-all-mean](https://akka.io/blog/mcp-a2a-acp-what-does-it-all-mean)

[\[34\]](https://eclipse.dev/lmos/docs/arc/adl/adl_cheat/#:~:text=Alternative%20Solution%20,Last%20resort%2C%20avoids%20loops) ADL cheat sheet | Eclipse LMOS

[https://eclipse.dev/lmos/docs/arc/adl/adl\_cheat/](https://eclipse.dev/lmos/docs/arc/adl/adl_cheat/)

[\[36\]](https://www.ibm.com/think/topics/ai-agent-protocols#:~:text=1,the%20format%20for%20data%20exchange) [\[40\]](https://www.ibm.com/think/topics/ai-agent-protocols#:~:text=,model%20and%20a%20websocket%20subprotocol) What Are AI Agent Protocols? | IBM

[https://www.ibm.com/think/topics/ai-agent-protocols](https://www.ibm.com/think/topics/ai-agent-protocols)