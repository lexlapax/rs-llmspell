searchState.loadedDescShard("llmspell_state_traits", 0, "ABOUTME: State management traits and interfaces for …\nConcurrent access conflicts\nConfiguration errors\nContains the error value\nGeneric internal errors\nInvalid state scope or key format\nIO errors from storage operations\nMigration errors\nState not found for the given scope and key\nContains the success value\nPermission/security errors\nResource limit errors\nSerialization/deserialization errors\nErrors that can occur during state operations\nResult type for state operations\nStorage backend errors\nCreate an already exists error (maps to invalid format …\nCreate a background task error (maps to internal error)\nCreate a backup error (maps to storage error)\nCreate a compression error (maps to storage error)\nCreate a concurrency error\nCreate a configuration error\nReturns the argument unchanged.\nCreate a hook error (maps to internal error)\nCreate an internal error\nCalls <code>U::from(self)</code>.\nCreate an invalid format error\nCreate an IO error\nCheck if this error indicates a missing/not found state\nCheck if this error indicates a permanent failure\nCheck if this error is retryable\nCreate a lock error (maps to concurrency error)\nCreate a migration error\nCreate a not found error\nCreate a permission denied error\nCreate a resource limit exceeded error\nCreate a serialization error\nCreate a storage error\nCreate a timeout error (maps to internal error)\nCreate a validation error (maps to invalid format error)\nAgent-specific scope\nCustom component scope\nGlobal application-wide scope\nHook-specific scope\nSession-specific scope\nHierarchical scope for state data organization\nTool-specific scope\nUser-specific scope\nWorkflow-specific scope\nCheck if this scope can access data from another scope\nReturns the argument unchanged.\nGet the scope identifier if it has one\nCalls <code>U::from(self)</code>.\nCheck if this scope is agent-specific\nCheck if this scope is custom\nCheck if this scope is global\nCheck if this scope is hook-specific\nCheck if this scope is session-specific\nCheck if this scope is tool-specific\nCheck if this scope is user-specific\nCheck if this scope is workflow-specific\nGet the parent scope if this scope has one\nParse a storage key back into scope and key components\nGet the prefix for this scope (used by <code>KeyManager</code>)\nGet the scope type as a string\nCreate a hierarchical key for storage\nComplete backup of a component’s state\nMetadata about a component’s state structure\nState persistence capabilities for component-specific data\nCore state management trait for all state operations\nMigration support for state schema changes\nState observation and hooks for monitoring state changes\nRegistry for state observers\nEnhanced state persistence trait for components with …\nTransaction-like operations for state management\nTransaction identifier for tracking state operations\nTyped state operations for compile-time type safety\nCreate a backup of the component’s state\nBegin a new transaction\nClear all values in a scope\nClear all persisted state for this component\nCommit a transaction, making all changes permanent\nCompare and swap operation for atomic updates\nGet the component’s unique identifier for state scoping\nUnique identifier of the component\nUnique identifier of the component\nGet the component type for scoping (tool, workflow, hook, …\nType of the component (tool, workflow, hook, agent, etc.)\nType of the component\nCopy all values from one scope to another\nGet the current schema version\nAdditional metadata specific to the component type\nDelete a value from the specified scope with the given key …\nDelete multiple keys within a scope\nDelete a value within a transaction\nCheck if a key exists in the specified scope\nExtract the component’s current state for persistence\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieve a value from the specified scope with the given …\nGet all key-value pairs in a scope\nRetrieve multiple values by keys within a scope\nRetrieve a value as JSON Value for manual deserialization\nRetrieve typed data with automatic deserialization\nIncrement a numeric value atomically\nCheck if this observer is interested in changes to the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhen the state was last updated\nList all keys within a scope\nMetadata about the component state\nMigrate data from one schema version to another\nMove all values from one scope to another (copy then clear …\nCheck if migration is needed for the given data\nCreate a new transaction ID\nNotify all interested observers of a scope clear\nNotify all interested observers of a state deletion\nNotify all interested observers of a state change\nGet the observer’s identifier\nCalled when a scope is cleared\nCalled when a state value is deleted\nCalled when a state value is set\nRaw key-value data from storage\nRegister an observer for state changes\nRestore from a backup\nRestore the component’s state from persisted data\nRollback a transaction, discarding all changes\nSchema version for state compatibility\nStore a value in the specified scope with the given key\nStore multiple key-value pairs atomically within a scope\nSet a value only if the key doesn’t exist\nSet a value within a transaction\nStore a serialized value directly as JSON Value\nStore typed data with automatic serialization\nStore data with expiration (if supported by backend)\nThe component’s structured state data\nList of state keys used by this component\nGet metadata about the component’s state structure\nGet the component’s state scope\nGet all supported migration paths\nCheck if transactions are supported by this implementation\nWhen the backup was created\nUnregister an observer by ID\nValidate that migrated data is correct\nValidate that restored state is compatible with this …")