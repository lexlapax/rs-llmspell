searchState.loadedDescShard("llmspell_hooks", 0, "LLMSpell Hooks\nABOUTME: Artifact-specific hook utilities and constants …\nABOUTME: Artifact collector hooks for automatically …\nABOUTME: Cross-component hook coordination for complex …\nDistributed Hook System\nPrelude module for convenient imports\nSelective Hook Registry\nHook point triggered after an artifact is created\nHook point triggered after an artifact is deleted\nHook point triggered after an artifact is modified\nHook point triggered after an artifact is validated\nHook point triggered when an artifact is accessed\nHook point triggered when an artifact is derived from …\nArtifact-specific hook point constants\nHook point triggered before an artifact is created\nHook point triggered before an artifact is deleted\nHook point triggered before an artifact is modified\nHook point triggered before an artifact is validated\nHook point triggered when validation fails\nAdd artifact information to hook context metadata\nConvert artifact event to hook point\nReturns the argument unchanged.\nExtract artifact information from hook context\nCalls <code>U::from(self)</code>.\nCheck if a hook point is artifact-related\nConvert string to HookPoint\nCache all hook results\nOnly cache specific result types\nOnly cache successful results (Continue, Modified)\nConfiguration for the caching hook\nBuilt-in caching hook for automatic result caching\nCaching hook performance metrics\nCaching strategy configuration\nCustom caching logic based on context\nGet the underlying cache\nWhether to cache errors\nGet cache statistics\nHook points to cache (empty means cache all)\nClear the cache\nDefault TTL for cached entries\nWhether to update TTL on cache hit\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum number of cached entries\nGet caching metrics\nMinimum execution time to cache (avoid caching very fast …\nCreate a new caching hook with default configuration\nHook points to never cache\nCaching strategy\nTTL extension amount on hit\nWhether to cache based on full context or just hook point\nCreate a new caching hook with custom configuration\nEnable or disable error caching\nSet maximum cache size\nSet minimum execution time for caching\nConfigure caching strategy\nSet TTL for cached entries\nAlert severity levels\nBudget alert configuration\nCost breakdown\nCost tracking configuration\nBuilt-in cost tracking hook for AI/ML operations\nCost tracking metrics\nModel-specific pricing\nProvider pricing information\nToken usage information\nCost aggregation window\nWhether to block operations when exceeded\nBudget alerts (sorted by threshold)\nGet component cost\nCurrency code (USD, EUR, etc.)\nDefault currency\nDefault currency for cost calculations\nWhether to emit cost events\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInput token cost\nCost per 1K input tokens\nInput/prompt tokens\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAlert level\nMaximum tokens allowed\nCustom message for alert\nGet cost tracking metrics\nMinimum charge per request (if any)\nModel name/identifier\nModel pricing configurations\nCreate a new cost tracking hook with default configuration\nOutput token cost\nCost per 1K output tokens\nOutput/completion tokens\nProvider name (OpenAI, Anthropic, etc.)\nProvider name\nProvider pricing configurations\nReset metrics\nAlert threshold amount\nTimestamp of calculation\nGet total cost\nTotal cost\nTotal tokens (input + output)\nWhether to track costs per component\nWhether to track costs per user\nGet user cost\nAdd budget alert\nCreate a new cost tracking hook with custom configuration\nAdd custom provider pricing\nDebug trace entry\nConfiguration for the debugging hook\nBuilt-in debugging hook for comprehensive trace capture\nDebug trace storage\nAdd a trace entry\nWhether to capture stack traces\nClear all traces\nClear all traces\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet debug statistics\nGet traces statistics\nGet all debug traces\nGet all traces\nGet traces for a specific component\nGet traces for a specific hook point\nGet traces within a time range\nWhether to include full context data\nWhether to include metadata\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether to log traces to console\nMaximum number of traces to keep in memory\nMinimum duration (in ms) to capture for performance …\nCreate a new debugging hook with default configuration\nGet the trace storage\nCreate a new debugging hook with custom configuration\nSet minimum duration threshold for trace capture (only …\nEnable or disable stack trace capture (only works on new …\nLog levels for the logging hook\nConfiguration for the logging hook\nBuilt-in logging hook for comprehensive hook execution …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhether to include detailed context data\nWhether to include metadata\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMinimum log level to capture\nWhether to log performance metrics\nMaximum data size to log (bytes)\nCreate a new logging hook with default configuration\nCreate a new logging hook with custom configuration\nEnable or disable context data logging\nSet the log level\nSet maximum data size to log\nEnable or disable performance logging\nHistogram data structure\nHistogram bucket for timing metrics\nMetric data point\nBuilt-in metrics hook for comprehensive performance …\nMetrics storage for the MetricsHook\nCustom metrics\nExecution duration histograms by hook point\nError counts by hook point\nExecution count by hook point\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet duration histogram for a hook point\nGet execution count for a hook point\nGet success rate for a hook point\nGet metrics summary\nGet all metrics summary\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new metrics hook\nRecord a custom metric\nRecord an execution\nGet the metrics storage\nSuccess counts by hook point\nEnable or disable custom metrics collection\nCreate a new metrics hook with shared storage\nCancel the operation\nCustom strategy\nDelay the operation\nGlobal rate limit (all requests share same bucket)\nPer-component rate limit\nPer-key rate limit (custom key generation)\nPer-user rate limit (requires user_id in context)\nAction to take when rate limited\nRate limit configuration\nBuilt-in rate limiting hook for API quota management\nRate limiting metrics\nRate limiting strategy\nRedirect to alternative endpoint\nReturn cached result if available\nWhether to add rate limit headers\nWhether to include burst capacity\nToken bucket configuration\nCustom rate limits per key\nWhether to emit events on rate limiting\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHeader prefix for rate limit headers\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet rate limiting metrics\nCreate a new rate limit hook with default configuration\nDefault action when rate limited\nReset metrics\nRate limiting strategy\nGrace period for near-limit warnings\nSet token bucket configuration\nSet burst capacity\nCreate a new rate limit hook with custom configuration\nAdd custom rate limit for specific key\nSet action when rate limited\nSet rate per second\nConfigure rate limiting strategy\nBackoff strategy for retries\nDecorrelated jitter\nEqual jitter (delay/2 to delay)\nExponential backoff with base * (multiplier ^ attempt)\nFibonacci backoff\nFixed delay between retries\nFull jitter (0 to delay)\nJitter strategy to prevent thundering herd\nLinear backoff with base + (increment * attempt)\nNo jitter\nRetry configuration\nBuilt-in retry hook with exponential backoff\nRetry metrics\nHook points to apply retry logic\nBackoff strategy\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nJitter strategy\nMaximum number of retry attempts\nMaximum total retry duration\nGet retry metrics\nCreate a new retry hook with default configuration\nSet of non-retryable error patterns (takes precedence)\nReset metrics\nWhether to retry on rate limit\nWhether to retry on timeout\nSet of retryable error patterns\nSet backoff strategy\nCreate a new retry hook with custom configuration\nSet jitter strategy\nSet maximum attempts\nAdd non-retryable error pattern\nAdd retryable error pattern\nActions to take when a security rule is triggered\nConfiguration for the security hook\nSecurity audit event\nSecurity event types\nBuilt-in security hook for comprehensive security …\nSecurity rule for validation\nSecurity event severity levels\nSecurity event storage\nAdd a security event\nAdd a custom security rule\nAdd a security rule\nWhether to block on security violations\nClear all events\nWhether to enable audit logging\nWhether to enable parameter validation\nWhether to enable rate limiting checks\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet all security events\nGet all security events\nGet events by severity\nGet events by type\nGet security rules for a hook point\nGet security statistics\nGet security statistics\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum number of events to keep in memory\nMaximum parameter value length\nMinimum severity level to log\nCreate a new security hook with default configuration\nSensitive parameter names to mask\nGet the security storage\nEnable or disable audit logging (only works on new …\nEnable or disable blocking on violations (only works on …\nCreate a new security hook with custom configuration\nSet minimum severity level (only works on new instance)\nThread-safe cache with TTL and LRU eviction\nCached entry with metadata\nCache key generated from hook context\nCache statistics\nLRU eviction policy\nConvert to string representation for storage\nForce cleanup of all expired entries\nClear all entries from the cache\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a cache key from hook context\nGet an entry from the cache\nGet keys to evict based on LRU policy\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if cache is empty\nCheck if the entry has expired\nUpdate access metadata\nCreate a new cache with specified configuration\nPut an entry into the cache\nRecord access to a key\nRemove an entry from the cache\nRemove key from tracking\nGet current cache size\nGet cache statistics\nThread-safe TTL-based cache\nTTL cache configuration\nTTL cache statistics\nTTL cache entry with expiration time\nAdditional TTL to add on access (if extend_on_access is …\nForce cleanup of expired entries\nCleanup interval for expired entries\nClear all entries from the cache\nCheck if the cache contains a key (and it’s not expired)\nDefault TTL for entries\nWhether to extend TTL on access\nExtend the TTL from now\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a value from the cache\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the cache is empty\nCheck if the entry has expired\nGet all non-expired keys\nGet the current size of the cache\nMark the entry as accessed\nMaximum number of entries\nCreate a new TTL entry\nCreate a new TTL cache with default configuration\nPut a value into the cache with default TTL\nPut a value into the cache with custom TTL\nGet the remaining TTL\nRemove a key from the cache\nReset TTL from creation time\nGet cache statistics\nCreate a new TTL cache with custom configuration\nCircuit breaker configuration\nBuilder for <code>BreakerConfig</code>\nCircuit breaker state\nCircuit breaker for hook execution\nCircuit breaker manager for multiple breakers\nPublic statistics structure\nCircuit is closed, normal operation\nCircuit is half-open, testing recovery\nCircuit is open, blocking calls\nGet all circuit breaker stats\nBuild the configuration\nCreate a new builder for <code>BreakerConfig</code>\nCheck if circuit allows execution\nConservative configuration for critical hooks\nCreate a builder from conservative defaults\nCreate a custom circuit breaker\nSet the failure threshold\nMaximum failures before opening circuit\nSet the failure window duration\nTime window for failure counting\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet or create a circuit breaker\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new circuit breaker\nCreate a new manager\nCreate a new builder with default configuration\nSet the open duration\nHow long to stay open before trying half-open\nProduction-optimized configuration for hook system\nCreate a builder from production-optimized defaults\nRecord a failed execution\nRecord a successful execution\nReset the circuit breaker\nReset all circuit breakers\nSet the slow call duration\nDuration that defines a slow call\nSet the slow call threshold\nMaximum consecutive slow operations\nGet current state\nGet circuit breaker statistics\nSet the success threshold\nSuccess threshold to close circuit from half-open\nCreate with custom configuration\nCreate with default configuration\nTrait for hooks that collect artifacts\nData extracted for artifact creation\nConfiguration for artifact collection\nABOUTME: Agent output collector for capturing agent …\nGet the artifact type for this collector\nTags to automatically add to collected artifacts\nWhether to collect error outputs\nGet collection configuration\nContent to store\nExtract artifact data from the context\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if content size is within configured limits\nMaximum size in bytes to collect (prevent huge artifacts)\nAdditional metadata\nMIME type\nMinimum size in bytes to collect (avoid tiny artifacts)\nName for the artifact\nSampling rate (0.0 to 1.0, where 1.0 collects everything)\nCheck if this context should result in artifact collection\nCheck if we should sample this collection (for rate …\nTags for the artifact\nABOUTME: Tool result collector for capturing tool …\nCollector for agent execution outputs\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCollector for tool execution results\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nComprehensive hook context with all necessary data\nBuilder for creating HookContext with fluent API\nOperation-specific context\nCreate a child context\nComponent that triggered the hook\nCorrelation ID for tracking related operations\nDynamic data associated with the hook\nGet the error message if this is an error context\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet data from the context\nGet metadata\nInsert data into the context\nInsert metadata\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this is an error context\nLanguage context for cross-language support\nString metadata for lightweight info\nCreate a new hook context\nOperation context (if applicable)\nGet operation parameters if available\nGet operation result if available\nParent context for nested hooks\nThe hook point being executed\nSet operation result\nTimestamp when the hook was triggered\nCreate with a correlation ID\nCreate with a specific language\nAdd operation context\nState of an execution chain\nChain completed successfully\nConfiguration for the cross-component coordinator\nContext for cross-component hook execution\nCross-component hook coordinator for managing complex …\nChain is currently executing\nRepresents an execution chain of components\nChain failed during execution\nChain is registered but not yet executing\nAdds a component to the execution chain\nExecution chain information\nTotal components in chain\nPosition in the execution chain\nRemoves a completed or failed chain\nComponents in execution order\nCorrelation ID for event tracking\nCreation timestamp\nCurrent component in the chain\nABOUTME: Dependency graph for managing hook execution …\nEnable event correlation tracking\nEnable performance isolation between components\nABOUTME: Event correlation system for tracking hook …\nExecutes hooks for the next component in a chain\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the current state of a chain\nGets performance metrics for a component\nGets the next component in the chain\nBase hook context\nUnique identifier for this chain\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks if this is the last component in the chain\nMaximum number of active chains\nMaximum total chain execution time\nMaximum execution time per component in a chain\nChain-level metadata\nName of the execution chain\nCreates a new cross-component coordinator\nCreates a new execution chain\nPerformance metrics from previous components\nPropagated data from previous components\nRegisters a new execution chain\nStarts execution of a registered chain\nCurrent execution state\nCreates a new coordinator with custom configuration\nAdds metadata to the chain\nSets the chain name\nCorrelation ID for tracking\nCorrelation ID for tracking\nCorrelation ID for tracking\nCurrent component index\nTotal execution duration\nPartial execution duration\nError message\nComponent where failure occurred\nExecution start time\nCircular dependency detected\nA dependency relationship between components\nError types for dependency graph operations\nDependency graph for managing hook execution order\nA node in the dependency graph representing a component\nResult of topological sorting with execution phases\nInvalid dependency relationship\nMissing dependency\nAdds a dependency relationship between components\nAdds a dependency with additional options\nAdds a hook point to this node\nAdds a component node to the graph\nComponent identifier\nComponent that this one depends on\nDetects circular dependencies in the graph\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the execution order using topological sort\nGets execution order for a specific hook point\nHook point where the dependency applies\nHook points that this component participates in\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether this is a hard dependency (must be satisfied) or …\nMetadata associated with this node\nCreates a new empty dependency graph\nCreates a new dependency node\nPhases of execution (components that can run in parallel)\nPriority for execution ordering\nOptional reason for the dependency\nRemoves a dependency relationship\nComponents in execution order\nAny warnings about the execution order\nAdds metadata to this node\nSets the priority for this node\nTrace was abandoned/cancelled\nTrace is actively collecting events\nTrace completed successfully\nComponent cleanup\nComponent initialization\nContext propagation event\nUnique identifier for correlating events across components\nConfiguration for event correlation\nCustom user-defined event\nEvent correlator for tracking cross-component hook …\nPerformance metrics captured at event time\nA complete trace of events for a correlation ID\nType of trace event\nTrace exceeded retention period\nTrace ended due to error\nHook execution completed successfully\nHook execution failed\nHook execution started\nPerformance warning\nAnalysis results for a trace\nIndividual event within a trace\nStatus of a trace\nAnalyzes trace performance\nGets the inner UUID\nIdentified bottlenecks\nMarks a trace as completed\nNumber of components involved\nDuration per component\nComponent that generated this event\nComponent-specific metrics\nComponents involved in this trace\nThe correlation ID for this trace\nThe correlation ID analyzed\nCPU usage percentage\nCreates a child correlation ID for nested operations\nCreates a new correlation ID for tracking events\nTrace creation time\nEvent-specific data\nDuration from trace start\nEnable causality tracking\nEnable detailed timing information\nTotal number of events\nEvent ID for uniqueness\nEvent type/category\nAll events in chronological order\nMarks a trace as failed\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a correlation ID from a UUID\nGets all active traces\nGets a complete trace\nGets traces for a specific component\nHook point where this event occurred\nDuration per hook point\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLast activity time\nMaximum number of active traces\nMaximum number of events per trace\nMemory usage at event time (bytes)\nHuman-readable event message\nMetadata for the trace\nPerformance metrics at time of event\nCreates a new correlation ID\nCreates a new event correlator\nOptional parent event (for causality)\nRecords an event in the trace\nRecords an event with full details\nStarts tracking a chain of components\nTrace status\nNumber of active threads\nEvent timestamp\nTotal execution duration\nTrace retention duration\nPerformance warnings\nCreates a new correlator with custom configuration\nExtended hook context for distributed execution\nBuilder for DistributedHookContext\nFlags controlling hook propagation across the network\nIdentifies a remote agent in the distributed system\nSecurity context for distributed hook execution\nAdd a remote execution result\nAgent identifier within the node\nCheck if all remote executions succeeded\nAllowed hook points for remote execution\nIP address restrictions\nAuthentication token or credentials\nWhether to wait for remote execution results\nBase hook context\nWhether this hook should be broadcast to all agents\nBuild the context\nCheck if propagation is allowed\nAgent capabilities/version for compatibility\nWhether to continue on remote failure\nCreate a propagated context for a target agent\nCurrent hop count\nAdditional distributed metadata\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate from a local hook context\nIncrement hop count for propagation\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if an agent is trusted\nCheck if a hook point is allowed\nCheck if this is a remote execution\nValidate timestamp to prevent replay attacks\nMaximum number of hops this hook can propagate\nAdd metadata\nOptional network address for direct communication\nSet network correlation ID\nNetwork correlation ID for tracing across agents\nPriority for network transmission\nCreate a new builder from a base context\nCreate a new remote agent identifier\nCreate a new security context with a nonce\nNode identifier (e.g., hostname, cluster node ID)\nNonce for uniqueness\nSet propagation flags\nPropagation control flags\nExecution results from remote agents\nTimeout for remote execution\nSet security context\nSecurity context\nCheck if propagation is enabled\nSignature for message integrity\nSet source agent\nSource agent that initiated the hook\nGet all successful remote results\nAdd target agent\nSpecific agents to propagate to (if not broadcasting)\nTarget agents for propagation\nTimestamp for replay attack prevention\nTrusted agent whitelist\nGet a unique identifier string\nAdd a network address\nAdd an allowed hook point\nSet authentication token\nSet whether to await remote execution\nEnable broadcasting\nAdd a capability\nSet maximum hops\nAdd distributed metadata\nSet propagation flags\nSet security context\nSet the source agent\nAdd a target agent\nAdd a target agent\nSet remote timeout\nAdd a trusted agent\nPer-hook execution configuration\nHook executor with performance protection\nBuilder for HookExecutor\nHook execution configuration\nCircuit breaker configuration\nCustom circuit breaker config\nConfigure a specific hook\nGet the correlation tracker\nEnable circuit breaker protection\nEnable performance monitoring\nEnable hook persistence\nExecute hooks for artifact events\nExecute a hook with protection\nExecute multiple hooks in sequence\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate performance report\nGet all performance metrics\nGet circuit breaker stats\nGet performance metrics for a hook\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if correlation tracking is enabled\nCheck if persistence is enabled\nCheck if overhead is within target\nMaximum execution time before circuit breaker triggers\nCreate a new hook executor\nPerformance monitoring configuration\nPerformance overhead target (e.g., 5%)\nWhether to persist this hook’s executions\nReset all circuit breakers\nReset circuit breaker for a hook\nRetention priority for persistence\nSet the correlation tracker for hook execution correlation\nSet the persistence manager for hook execution history\nCustom timeout for this hook\nWhether circuit breaker is enabled for this hook\nCreate with custom configuration\nTimer for tracking execution duration\nConfiguration for performance monitoring\nPerformance metrics for a hook\nPerformance monitor for hook execution\nPerformance report for diagnostics\nEnable percentile calculations\nClear all metrics\nClear metrics for a specific hook\nComplete the timing and record the duration\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a performance report\nGet all hook metrics\nGet performance metrics for a hook\nGet hooks exceeding performance threshold\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a hook is performing within threshold\nMaximum samples to keep per hook\nCreate a new performance monitor\nRecord an execution duration\nSample retention duration\nStart tracking a hook execution\nCreate with custom configuration\nCaptured state during replay\nComparison result between two execution sets\nExecution analysis results\nPattern detection results\nFile-based storage backend\nHook execution inspector\nHook-specific metadata for enhanced storage\nEnhanced hook persistence manager\nHook replay engine for reconstructing executions\nInterface for hook replay management\nHook storage adapter for metadata persistence\nIn-memory storage backend (for testing and development)\nInspection query for filtering executions\nBreakpoint for debugging replay\nReplay error information\nAdvanced replay manager with debugging capabilities\nOptions for replaying hook executions\nReplay session state\nReplay session configuration\nReplay timeline for visualization\nManages retention policies for different hook types\nRetention policy configuration for hooks\nSerialized hook execution for persistence\nStorage backend trait for hook persistence\nStorage statistics for monitoring\nStorage statistics\nAdd breakpoint to session\nAdd a tag to the metadata\nAnalyze executions\nApply retention policies to all hook types\nApply retention policies to a specific hook type\nWhether to archive hooks before deletion\nArchive old executions\nArchive old executions\nBreak on errors during replay\nBuild timeline from executions\nWhether to capture intermediate states\nCleanup storage based on retention policies\nClear the metadata cache\nClear all custom policies (revert to default)\nCompare two sets of executions\nComponent ID that triggered the hook\nFilter by component ID pattern\nCompression settings for archived hooks\nConfigure retention policy for a specific hook type\nWhether the hook context contains sensitive data\nSize of serialized hook context in bytes\nFilter by correlation ID\nTimestamp when metadata was created\nCustom parameters to use during replay\nCustom properties specific to the hook type\nDelete an execution\nDelete metadata\nDetect execution patterns\nWhether to skip side effects\nEnd replay session\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet hook executions with enhanced metadata\nGet hook executions by correlation ID\nGet retention policy for a hook type\nGet a custom property\nGet replay session\nGet storage statistics\nGet replay statistics\nGet retention statistics\nGet storage statistics\nGet storage statistics\nFilter by hook IDs\nFilter by hook points\nHook type (e.g., “rate_limit”, “cost_tracking”, “…\nFilter by hook types\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum results to return\nList metadata keys by prefix\nLoad a hook execution by ID\nLoad all executions for a correlation ID\nLoad hook metadata\nCreate a policy for long-term retention\nMaximum age of hook executions to retain\nMaximum number of executions to retain per hook type\nMaximum executions to replay\nMaximum memory for captured states\nMinimum number to always keep regardless of age\nWhether this hook modified the operation\nWhether to modify parameters during replay\nSession name for identification\nCreate a new inspector\nCreate a new replay engine\nCreate a new replay manager\nCreate a new retention manager with default policy\nCreate a new hook storage adapter\nCreate a new hook persistence manager\nCreate new hook metadata\nPersist a hook execution with metadata and retention …\nPersist a hook execution\nAdditional time to retain high-priority hooks\nPriority threshold - keep hooks with priority &gt;= this …\nQuery executions based on filters\nRegister a replayable hook\nReplay executions by correlation ID\nReplay a single hook execution\nReplay multiple hook executions\nReplay specific executions\nReset statistics\nFilter by result type\nCreate a policy that retains everything\nRetention priority (higher = keep longer)\nSet persistent state manager\nSet retention policy for a specific hook type\nSet a custom property\nCreate a policy for short-term retention\nCheck if a hook execution should be retained based on age …\nWhether to simulate the original timing\nSpeed multiplier for replay (1.0 = real-time)\nStart a new replay session\nStore a hook execution\nStore hook metadata\nTags for categorization and searching\nFilter by time range\nComponent that triggered the hook\nWhether to validate hook outputs\nConfigure with persistent state manager\nCreate with a specific storage backend\nContains the error value\nContains the success value\n<code>Result&lt;T, Error&gt;</code>\nPriority buckets for grouping hooks\nBuilder for custom priority configurations\nPriority comparator for hook ordering\nCreate a priority after the base (lower priority)\nCreate a priority before the base (higher priority)\nCompare two priorities for execution order Lower priority …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet priority bucket for grouping\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a priority is within a range\nGet the display name for the bucket\nCreate a new priority builder starting from a base value\nCreate a priority relative to the base\nGet the priority range for this bucket\nSort a slice of items by priority\nBucket state information\nThread-safe rate limiter with multiple buckets\nRate limiter configuration\nToken bucket configuration\nWhether to allow creating new buckets on demand\nTTL for unused buckets\nAdditional burst capacity beyond normal capacity\nBurst capacity\nMaximum number of tokens in the bucket\nMaximum capacity\nDefault token bucket configuration\nForce acquire tokens (may go negative)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the current state of a bucket\nGet statistics for all buckets\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLast access time\nLast refill amount\nMaximum number of buckets to maintain\nCreate a new rate limiter with default configuration\nNext refill time\nInterval at which tokens are refilled\nRate at which tokens are refilled\nReset all buckets\nReset a specific bucket\nCurrent number of tokens\nTotal tokens consumed\nTotal tokens refilled\nWhether to track per-bucket statistics\nTry to acquire tokens from a bucket\nCreate a new rate limiter with custom configuration\nToken bucket implementation\nForce acquire tokens (may go negative)\nReturns the argument unchanged.\nGet bucket state\nGet current token count\nCalls <code>U::from(self)</code>.\nCreate a new token bucket\nReset the bucket to full capacity\nTry to acquire tokens\nHook registry for managing hooks by point\nConfiguration for HookRegistry\nBuilder for HookRegistryConfig\nRegistry errors\nRegistry statistics\nBuild the configuration\nCreate a new builder for HookRegistry configuration\nClear all hooks\nClear all hooks for a specific point\nSet whether to track statistics\nWhether to track statistics\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet hook names for a point\nGet all registered hook points\nGet all hooks for a point\nGet hooks filtered by language\nGet hooks filtered by priority range\nSet whether hooks are globally enabled by default\nWhether hooks are globally enabled by default\nCheck if a hook exists\nSet the initial capacity for the hooks map\nInitial capacity for the hooks map\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if hooks are globally enabled\nCreate a new hook registry with default configuration\nCreate a new builder with default configuration\nRegister a hook for a specific point\nRegister an Arc’d hook\nRegister multiple hooks at once\nEnable or disable all hooks globally\nEnable or disable a specific hook\nGet registry statistics\nUnregister a hook by name\nCreate a new hook registry with custom configuration\nBatch replay request\nBatch replay response\nExecute with debugging enabled\nExecute exactly as recorded\nAllow parameter modifications\nParameter modification for replay\nReplay configuration\nReplay execution mode\nReplay execution result\nSimulate execution without running hooks\nApplied modifications\nWhether to compare results with original\nComparison with original if requested\nCommon configuration for all replays\nDuration of replay\nWhether to apply this modification\nExecutions to replay\nFailure count\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHook name that was replayed\nResult from hook execution\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum concurrent replays if parallel\nExecution metadata\nBatch metadata\nExecution mode\nParameter modifications to apply\nOriginal execution ID\nWhether to run in parallel\nPath to the parameter (e.g., “context.data.input”)\nUnique replay ID\nIndividual replay results\nStart time of replay\nWhether to stop on first error\nSuccess count\nTags for categorizing replays\nTimeout for each hook execution\nTotal duration\nNew value for the parameter\nDifferent cancellation reasons\nComparator configuration\nResult of comparing two hook executions\nCritical difference\nSame variant but different data\nA specific difference found\nSeverity of a difference\nType of difference between results\nDifferent error types\nHook result comparator\nInformational only\nMajor difference\nMinor difference\nMultiple differences\nDifferent result variants (Continue vs Modified, etc.)\nCompare two hook results\nWhether to perform deep comparison\nDescription of the difference\nType of difference if not identical\nDetailed differences\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhether the results are identical\nWhether to ignore order in arrays\nFields to ignore in comparison\nWhether to ignore timestamp differences\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new comparator with default config\nOriginal value\nPath to the difference (e.g., “data.field.subfield”)\nReplayed value\nSeverity of the difference\nSimilarity score (0.0 to 1.0)\nSummary of the comparison\nCreate a comparator with custom config\nEnhanced replay manager\nReplay request for a single hook execution\nReplay response\nBatch replay multiple executions\nCancel an active replay\nClean up completed replays\nReplay configuration\nOptional correlation ID for tracking\nExecution ID to replay\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet active replay status\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new replay manager\nRegister a hook for replay\nReplay a single hook execution\nReplay result\nSchedule a replay for later execution\nAny warnings during replay\nExecute at a specific time\nCron-like schedule (simplified)\nExecute repeatedly at intervals\nExecute once after a delay\nReplay schedule configuration\nReplay scheduler\nScheduled replay entry\nWhether this schedule is active\nCancel a scheduled replay\nCreation time\nNumber of times executed\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet all scheduled replays\nGet a specific scheduled replay\nUnique ID for this scheduled replay\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLast execution time\nLast execution result\nCreate a new replay scheduler\nWhen to execute next\nThe replay request to execute\nSchedule a replay\nSchedule configuration\nStop the scheduler\nCache the result with a key and TTL\nCancel the operation with a reason\nContinue normal execution\nFork into parallel operations\nBuilder for creating HookResult::Fork\nEnhanced hook result with production patterns\nModify the operation parameters or context\nOperation descriptor for Fork results\nRedirect to a different operation\nReplace the entire operation result\nRetry the operation with delay and max attempts\nBuilder for creating HookResult::Retry\nSkip this hook (used by circuit breaker)\nGet a human-readable description of the result\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the result cancels execution\nCheck if the result requires special handling\nCheck if the result allows continuation\nHook factory function type\nFeature flags for selective hook loading\nLazy hook entry\nSelective hook registry with lazy loading and feature flags\nConfiguration for selective registry\nStatistics for selective registry\nAdd feature dependency\nCheck if all required features are enabled\nClear all instantiated hooks to free memory\nEnable statistics collection\nDefault features for new hooks\nDisable a feature\nEnable a feature\nGet all enabled features\nEviction count\nFeature usage\nGet current features\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet hooks for a point (only instantiates if features are …\nGet hooks filtered by language\nHook access counts\nCurrently instantiated hooks\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a feature is enabled\nMaximum number of lazy hooks to keep instantiated\nGet memory usage estimate\nCreate new selective registry\nCreate new feature set with all features disabled\nPreload a hook by name\nPreload hooks for these points\nRegister a simple hook without features\nRegister a hook with feature requirements\nEnable or disable a feature\nSet global enable flag\nEnable or disable a hook\nGet statistics\nTotal registered hooks\nWhether to use LRU eviction for instantiated hooks\nCreate with custom configuration\nCreate with specific features enabled\nType alias for an arc’d hook\nType alias for a boxed hook\nTrait for hooks that can be composed\nThe language-specific context type\nA wrapper to make closures into hooks\nBase hook trait for all hooks in the system\nLanguage adapter for cross-language hook support\nExtension trait for hooks\nTrait for hooks that track metrics\nTrait for hooks that can be replayed from persisted state …\nThe language-specific result type\nAdapt the universal context to language-specific format\nAdapt the language-specific result to universal format\nConvert to an arc’d hook\nGet self as Any for downcasting\nConvert to a boxed hook\nCheck if this hook can be composed with another\nGet the composition priority\nDeserialize the context from persistence\nExecute the hook with the given context\nGet the error from a language-specific result if any\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCheck if this hook supports replay\nGet metadata about this hook\nRecord metrics after execution\nRecord metrics before execution\nGet a replay identifier for this hook\nSerialize the context for persistence\nCheck if this hook should be executed for the given context\nComponent identifier for hook context\nTypes of components that can trigger hooks\nHook metadata\nAll possible hook points in the system\nLanguages supported by the hook system\nHook priority for execution ordering\nCreate a builder starting from this priority\nGet the distance between two priorities\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this priority is higher than another (executes …\nCheck if this priority is lower than another (executes …")