//! ABOUTME: Core types for the artifact storage system
//! ABOUTME: Defines `ArtifactId`, `ArtifactType`, and metadata structures

use crate::SessionId;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fmt;

/// Maximum size for a single artifact (100MB)
pub const MAX_ARTIFACT_SIZE: usize = 100 * 1024 * 1024;

/// Maximum length for artifact names
pub const MAX_ARTIFACT_NAME_LENGTH: usize = 255;

/// Maximum length for tags
pub const MAX_TAG_LENGTH: usize = 64;

/// Content hash type for artifacts (using blake3 for performance)
pub type ContentHash = String;

/// Unique identifier for an artifact
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ArtifactId {
    /// Content hash (blake3) of the artifact
    pub content_hash: ContentHash,
    /// Session this artifact belongs to
    pub session_id: SessionId,
    /// Sequence number within the session
    pub sequence: u64,
}

impl ArtifactId {
    /// Create a new artifact ID
    pub fn new(content_hash: ContentHash, session_id: SessionId, sequence: u64) -> Self {
        Self {
            content_hash,
            session_id,
            sequence,
        }
    }

    /// Generate a storage key for this artifact
    pub fn storage_key(&self) -> String {
        format!(
            "artifact:{}:{}:{}",
            self.session_id, self.sequence, self.content_hash
        )
    }

    /// Get just the content key (for deduplication)
    pub fn content_key(&self) -> String {
        format!("content:{}", self.content_hash)
    }
}

impl fmt::Display for ArtifactId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{}/{}/{}",
            self.session_id,
            self.sequence,
            &self.content_hash[..8] // First 8 chars of hash
        )
    }
}

/// Type of artifact stored
#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub enum ArtifactType {
    /// Output from an agent execution
    AgentOutput,
    /// Result from a tool execution
    ToolResult,
    /// Input provided by the user
    UserInput,
    /// Generated by the system (logs, metrics, etc.)
    SystemGenerated,
    /// Custom artifact type with description
    Custom(String),
}

impl ArtifactType {
    /// Get a human-readable name for the artifact type
    pub fn as_str(&self) -> &str {
        match self {
            ArtifactType::AgentOutput => "agent_output",
            ArtifactType::ToolResult => "tool_result",
            ArtifactType::UserInput => "user_input",
            ArtifactType::SystemGenerated => "system_generated",
            ArtifactType::Custom(s) => s,
        }
    }
}

impl fmt::Display for ArtifactType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

/// Version information for an artifact
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct ArtifactVersion {
    /// Version number (starts at 1)
    pub version: u32,
    /// Previous version's content hash (if any)
    pub previous_hash: Option<ContentHash>,
    /// When this version was created
    pub created_at: DateTime<Utc>,
}

/// Metadata for an artifact
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ArtifactMetadata {
    /// Human-readable name
    pub name: String,
    /// Optional description
    pub description: Option<String>,
    /// Artifact type
    pub artifact_type: ArtifactType,
    /// MIME type of the content
    pub mime_type: String,
    /// Size in bytes
    pub size: usize,
    /// Tags for categorization
    pub tags: Vec<String>,
    /// Custom key-value metadata
    pub custom: HashMap<String, serde_json::Value>,
    /// Version information
    pub version: ArtifactVersion,
    /// When the artifact was created
    pub created_at: DateTime<Utc>,
    /// Who created the artifact (user ID, agent ID, etc.)
    pub created_by: Option<String>,
    /// Parent artifact reference (for derived artifacts)
    pub parent_artifact: Option<ArtifactId>,
    /// Whether this artifact is compressed
    pub is_compressed: bool,
    /// Original size before compression
    pub original_size: Option<usize>,
}

impl ArtifactMetadata {
    /// Create new metadata with defaults
    pub fn new(name: String, artifact_type: ArtifactType, size: usize) -> Self {
        Self {
            name,
            description: None,
            artifact_type,
            mime_type: "application/octet-stream".to_string(),
            size,
            tags: Vec::new(),
            custom: HashMap::new(),
            version: ArtifactVersion {
                version: 1,
                previous_hash: None,
                created_at: Utc::now(),
            },
            created_at: Utc::now(),
            created_by: None,
            parent_artifact: None,
            is_compressed: false,
            original_size: None,
        }
    }

    /// Validate the metadata
    ///
    /// # Errors
    ///
    /// Returns an error string if validation fails
    pub fn validate(&self) -> Result<(), String> {
        // Check name length
        if self.name.is_empty() {
            return Err("Artifact name cannot be empty".to_string());
        }
        if self.name.len() > MAX_ARTIFACT_NAME_LENGTH {
            return Err(format!(
                "Artifact name exceeds maximum length of {MAX_ARTIFACT_NAME_LENGTH} characters"
            ));
        }

        // Check size limits
        if self.size > MAX_ARTIFACT_SIZE {
            return Err(format!(
                "Artifact size {} exceeds maximum of {MAX_ARTIFACT_SIZE} bytes",
                self.size
            ));
        }

        // Check tag lengths
        for tag in &self.tags {
            if tag.len() > MAX_TAG_LENGTH {
                return Err(format!(
                    "Tag '{tag}' exceeds maximum length of {MAX_TAG_LENGTH} characters"
                ));
            }
        }

        // Validate MIME type format (basic check)
        if !self.mime_type.contains('/') {
            return Err(format!("Invalid MIME type: {}", self.mime_type));
        }

        Ok(())
    }

    /// Add a tag if it doesn't already exist
    ///
    /// # Errors
    ///
    /// Returns an error if the tag exceeds the maximum length
    pub fn add_tag(&mut self, tag: String) -> Result<(), String> {
        if tag.len() > MAX_TAG_LENGTH {
            return Err(format!(
                "Tag exceeds maximum length of {MAX_TAG_LENGTH} characters"
            ));
        }
        if !self.tags.contains(&tag) {
            self.tags.push(tag);
        }
        Ok(())
    }

    /// Set custom metadata value
    pub fn set_custom(&mut self, key: String, value: serde_json::Value) {
        self.custom.insert(key, value);
    }

    /// Get custom metadata value
    pub fn get_custom(&self, key: &str) -> Option<&serde_json::Value> {
        self.custom.get(key)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_artifact_id_creation() {
        let session_id = SessionId::new();
        let content_hash = "abc123def456".to_string();
        let artifact_id = ArtifactId::new(content_hash.clone(), session_id, 1);

        assert_eq!(artifact_id.content_hash, content_hash);
        assert_eq!(artifact_id.session_id, session_id);
        assert_eq!(artifact_id.sequence, 1);
    }
    #[test]
    fn test_artifact_id_keys() {
        let session_id = SessionId::new();
        let artifact_id = ArtifactId::new("hash123".to_string(), session_id, 42);

        let storage_key = artifact_id.storage_key();
        assert!(storage_key.contains("artifact:"));
        assert!(storage_key.contains("42"));
        assert!(storage_key.contains("hash123"));

        let content_key = artifact_id.content_key();
        assert_eq!(content_key, "content:hash123");
    }
    #[test]
    fn test_artifact_type_display() {
        assert_eq!(ArtifactType::AgentOutput.as_str(), "agent_output");
        assert_eq!(ArtifactType::ToolResult.as_str(), "tool_result");
        assert_eq!(ArtifactType::UserInput.as_str(), "user_input");
        assert_eq!(ArtifactType::SystemGenerated.as_str(), "system_generated");
        assert_eq!(
            ArtifactType::Custom("my_type".to_string()).as_str(),
            "my_type"
        );
    }
    #[test]
    fn test_metadata_validation() {
        let mut metadata =
            ArtifactMetadata::new("test.txt".to_string(), ArtifactType::UserInput, 1024);

        // Valid metadata
        assert!(metadata.validate().is_ok());

        // Empty name
        metadata.name = String::new();
        assert!(metadata.validate().is_err());

        // Name too long
        metadata.name = "a".repeat(MAX_ARTIFACT_NAME_LENGTH + 1);
        assert!(metadata.validate().is_err());

        // Size too large
        metadata.name = "test.txt".to_string();
        metadata.size = MAX_ARTIFACT_SIZE + 1;
        assert!(metadata.validate().is_err());

        // Tag too long
        metadata.size = 1024;
        metadata.tags.push("t".repeat(MAX_TAG_LENGTH + 1));
        assert!(metadata.validate().is_err());

        // Invalid MIME type
        metadata.tags.clear();
        metadata.mime_type = "invalid".to_string();
        assert!(metadata.validate().is_err());
    }
    #[test]
    fn test_metadata_tags() {
        let mut metadata =
            ArtifactMetadata::new("test.txt".to_string(), ArtifactType::UserInput, 1024);

        // Add valid tag
        assert!(metadata.add_tag("important".to_string()).is_ok());
        assert_eq!(metadata.tags.len(), 1);

        // Add duplicate tag (should not add)
        assert!(metadata.add_tag("important".to_string()).is_ok());
        assert_eq!(metadata.tags.len(), 1);

        // Add tag that's too long
        let long_tag = "t".repeat(MAX_TAG_LENGTH + 1);
        assert!(metadata.add_tag(long_tag).is_err());
        assert_eq!(metadata.tags.len(), 1);
    }
    #[test]
    fn test_custom_metadata() {
        let mut metadata =
            ArtifactMetadata::new("test.txt".to_string(), ArtifactType::UserInput, 1024);

        // Set custom values
        metadata.set_custom("author".to_string(), serde_json::json!("Alice"));
        metadata.set_custom("version".to_string(), serde_json::json!(2));

        // Get custom values
        assert_eq!(
            metadata.get_custom("author"),
            Some(&serde_json::json!("Alice"))
        );
        assert_eq!(metadata.get_custom("version"), Some(&serde_json::json!(2)));
        assert_eq!(metadata.get_custom("missing"), None);
    }
}
