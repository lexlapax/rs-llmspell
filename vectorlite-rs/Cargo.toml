[package]
name = "vectorlite-rs"
description = "Pure Rust HNSW vector search extension for SQLite"
version.workspace = true
edition.workspace = true
authors.workspace = true
repository.workspace = true
license.workspace = true

[lib]
# Build as standard Rust library for static linking
# crate-type = ["cdylib", "rlib"] # Old dynamic loading setup
path = "src/lib.rs"

[dependencies]
# HNSW vector indexing
hnsw_rs = "0.3.2"

# Using standard rusqlite.
# For static linking, we don't need "loadable_extension" or "vtab".
# The host (llmspell-storage) provides the SQLite implementation via its own rusqlite/libsql dependency.
# WE MUST USE "bundled" or rely on the host's linker if we were a dylib,
# but as an rlib, we just compile against rusqlite traits.
# IMPORTANT: common rusqlite version is critical.
rusqlite = { version = "0.32", default-features = false, features = ["vtab"] }
# libsqlite3-sys removed (no longer needed for manual API init)

# Serialization for metadata and configuration
serde = { workspace = true, features = ["derive"] }
serde_json = { workspace = true }
# MessagePack for HNSW index persistence
rmp-serde = "1.1"

# Error handling
anyhow = { workspace = true }
thiserror = { workspace = true }

# Zero-copy Vec<f32> marshaling for SQLite BLOBs
zerocopy = { workspace = true }

# Logging
tracing = { workspace = true }

[features]
default = []
# bundled feature removed - libsql-rusqlite uses libsql's SQLite implementation

[dev-dependencies]
tempfile = { workspace = true }
criterion = { workspace = true }
