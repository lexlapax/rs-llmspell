// TaskFlow Backend - Node.js + Express + GraphQL
// Generated by WebApp Creator v1.0

const express = require('express');
const { graphqlHTTP } = require('express-graphql');
const { buildSchema } = require('graphql');
const cors = require('cors');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const { Pool } = require('pg');
const socketIO = require('socket.io');
const http = require('http');

// Initialize Express app
const app = express();
const server = http.createServer(app);
const io = socketIO(server, {
  cors: {
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    credentials: true
  }
});

// Database connection
const pool = new Pool({
  connectionString: process.env.DATABASE_URL || 'postgresql://localhost/taskflow'
});

// GraphQL Schema
const schema = buildSchema(`
  type User {
    id: ID!
    name: String!
    email: String!
    role: String!
    teams: [Team!]!
  }

  type Team {
    id: ID!
    name: String!
    members: [User!]!
    projects: [Project!]!
  }

  type Project {
    id: ID!
    name: String!
    description: String
    team: Team!
    tasks: [Task!]!
    progress: Float!
    createdAt: String!
    updatedAt: String!
  }

  type Task {
    id: ID!
    title: String!
    description: String
    status: TaskStatus!
    priority: Priority!
    assignee: User
    project: Project!
    dueDate: String
    createdAt: String!
    updatedAt: String!
    comments: [Comment!]!
  }

  type Comment {
    id: ID!
    content: String!
    author: User!
    task: Task!
    createdAt: String!
  }

  enum TaskStatus {
    TODO
    IN_PROGRESS
    IN_REVIEW
    DONE
  }

  enum Priority {
    LOW
    MEDIUM
    HIGH
    URGENT
  }

  type Query {
    currentUser: User
    projects: [Project!]!
    project(id: ID!): Project
    tasks(projectId: ID, status: TaskStatus): [Task!]!
    task(id: ID!): Task
    team(id: ID!): Team
  }

  type Mutation {
    login(email: String!, password: String!): AuthPayload!
    createProject(input: ProjectInput!): Project!
    updateProject(id: ID!, input: ProjectInput!): Project!
    createTask(input: TaskInput!): Task!
    updateTask(id: ID!, input: TaskInput!): Task!
    deleteTask(id: ID!): Boolean!
    assignTask(taskId: ID!, userId: ID!): Task!
    addComment(taskId: ID!, content: String!): Comment!
  }

  type Subscription {
    taskUpdated(projectId: ID!): Task!
    projectUpdated(id: ID!): Project!
    newComment(taskId: ID!): Comment!
  }

  type AuthPayload {
    token: String!
    user: User!
  }

  input ProjectInput {
    name: String!
    description: String
    teamId: ID!
  }

  input TaskInput {
    title: String!
    description: String
    projectId: ID!
    status: TaskStatus
    priority: Priority
    assigneeId: ID
    dueDate: String
  }
`);

// GraphQL Resolvers
const root = {
  // Query resolvers
  currentUser: async (args, context) => {
    if (!context.user) return null;
    const result = await pool.query('SELECT * FROM users WHERE id = $1', [context.user.id]);
    return result.rows[0];
  },

  projects: async (args, context) => {
    if (!context.user) throw new Error('Unauthorized');
    const result = await pool.query(
      'SELECT p.* FROM projects p JOIN team_members tm ON p.team_id = tm.team_id WHERE tm.user_id = $1',
      [context.user.id]
    );
    return result.rows;
  },

  tasks: async ({ projectId, status }, context) => {
    if (!context.user) throw new Error('Unauthorized');
    let query = 'SELECT * FROM tasks WHERE 1=1';
    const params = [];
    
    if (projectId) {
      params.push(projectId);
      query += ` AND project_id = $${params.length}`;
    }
    
    if (status) {
      params.push(status);
      query += ` AND status = $${params.length}`;
    }
    
    const result = await pool.query(query, params);
    return result.rows;
  },

  // Mutation resolvers
  login: async ({ email, password }) => {
    const userResult = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
    const user = userResult.rows[0];
    
    if (!user || !await bcrypt.compare(password, user.password_hash)) {
      throw new Error('Invalid credentials');
    }
    
    const token = jwt.sign({ id: user.id }, process.env.JWT_SECRET || 'secret', {
      expiresIn: '7d'
    });
    
    return { token, user };
  },

  createTask: async ({ input }, context) => {
    if (!context.user) throw new Error('Unauthorized');
    
    const { title, description, projectId, status, priority, assigneeId, dueDate } = input;
    
    const result = await pool.query(
      `INSERT INTO tasks (title, description, project_id, status, priority, assignee_id, due_date, created_by)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING *`,
      [title, description, projectId, status || 'TODO', priority || 'MEDIUM', assigneeId, dueDate, context.user.id]
    );
    
    const task = result.rows[0];
    
    // Emit real-time update
    io.to(`project:${projectId}`).emit('taskCreated', task);
    
    return task;
  },

  updateTask: async ({ id, input }, context) => {
    if (!context.user) throw new Error('Unauthorized');
    
    const updates = [];
    const params = [id];
    let paramCount = 1;
    
    Object.entries(input).forEach(([key, value]) => {
      if (value !== undefined) {
        paramCount++;
        params.push(value);
        updates.push(`${key} = $${paramCount}`);
      }
    });
    
    const result = await pool.query(
      `UPDATE tasks SET ${updates.join(', ')}, updated_at = NOW() WHERE id = $1 RETURNING *`,
      params
    );
    
    const task = result.rows[0];
    
    // Emit real-time update
    io.to(`project:${task.project_id}`).emit('taskUpdated', task);
    
    return task;
  }
};

// Middleware
app.use(cors());
app.use(express.json());

// Authentication middleware
const authenticate = async (req) => {
  const token = req.headers.authorization?.replace('Bearer ', '');
  if (!token) return null;
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'secret');
    return { id: decoded.id };
  } catch {
    return null;
  }
};

// GraphQL endpoint
app.use('/graphql', graphqlHTTP(async (req) => ({
  schema: schema,
  rootValue: root,
  graphiql: process.env.NODE_ENV === 'development',
  context: {
    user: await authenticate(req)
  }
})));

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// WebSocket handling for real-time collaboration
io.on('connection', (socket) => {
  console.log('New client connected:', socket.id);
  
  socket.on('joinProject', (projectId) => {
    socket.join(`project:${projectId}`);
    socket.to(`project:${projectId}`).emit('userJoined', socket.id);
  });
  
  socket.on('leaveProject', (projectId) => {
    socket.leave(`project:${projectId}`);
    socket.to(`project:${projectId}`).emit('userLeft', socket.id);
  });
  
  socket.on('typing', ({ projectId, taskId, userId }) => {
    socket.to(`project:${projectId}`).emit('userTyping', { taskId, userId });
  });
  
  socket.on('disconnect', () => {
    console.log('Client disconnected:', socket.id);
  });
});

// Start server
const PORT = process.env.PORT || 4000;
server.listen(PORT, () => {
  console.log(`ðŸš€ TaskFlow backend running on http://localhost:${PORT}`);
  console.log(`ðŸ“Š GraphQL playground: http://localhost:${PORT}/graphql`);
  console.log(`ðŸ”Œ WebSocket server ready for real-time collaboration`);
});